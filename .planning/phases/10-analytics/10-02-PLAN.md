---
phase: 10-analytics
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/services/contentAnalyticsService.js
autonomous: true

must_haves:
  truths:
    - "Service can fetch content metrics for a specific content item"
    - "Service can fetch content performance list sorted by view time"
    - "Service can fetch viewing heatmap data"
  artifacts:
    - path: "src/services/contentAnalyticsService.js"
      provides: "Content analytics API functions"
      exports: ["getContentMetrics", "getContentPerformanceList", "getViewingHeatmap"]
  key_links:
    - from: "getContentMetrics"
      to: "supabase.rpc"
      via: "get_content_metrics call"
      pattern: "supabase\\.rpc.*get_content_metrics"
    - from: "getViewingHeatmap"
      to: "supabase.rpc"
      via: "get_viewing_heatmap call"
      pattern: "supabase\\.rpc.*get_viewing_heatmap"
---

<objective>
Extend contentAnalyticsService.js with functions that call the new database RPCs from migration 118.

Purpose: Provide frontend-callable API for content metrics, performance list, and viewing heatmap.
Output: 3 new exported functions in contentAnalyticsService.js.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-analytics/10-01-SUMMARY.md

@src/services/contentAnalyticsService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getContentMetrics function</name>
  <files>src/services/contentAnalyticsService.js</files>
  <action>
Add new function after the existing analytics functions (around line 190, after getSceneAnalyticsDetail):

```javascript
// ============================================================================
// CONTENT-SPECIFIC METRICS (Phase 10)
// ============================================================================

/**
 * Get view duration and completion rate for specific content
 * @param {string} contentId - Scene/media/playlist UUID
 * @param {string} contentType - 'scene' | 'media' | 'playlist'
 * @param {string} dateRange - Date range preset
 * @returns {Promise<Object>} Content metrics
 */
export async function getContentMetrics(contentId, contentType, dateRange = '7d') {
  const tenantId = await getEffectiveOwnerId();
  if (!tenantId) throw new Error('No tenant context');

  const { fromTs, toTs } = getDateRange(dateRange);

  const { data, error } = await supabase.rpc('get_content_metrics', {
    p_tenant_id: tenantId,
    p_content_id: contentId,
    p_content_type: contentType,
    p_from_ts: fromTs,
    p_to_ts: toTs,
  });

  if (error) throw error;
  return data?.[0] || {
    avg_view_duration_seconds: 0,
    completion_rate: 0,
    total_views: 0,
    last_viewed_at: null,
    total_view_time_seconds: 0,
  };
}
```

Follow existing patterns:
- Use getEffectiveOwnerId() for tenant context
- Use getDateRange() helper for date calculation
- Return sensible defaults on empty data
  </action>
  <verify>Check function exists: `grep -A 5 'getContentMetrics' src/services/contentAnalyticsService.js | head -10`</verify>
  <done>getContentMetrics function exported and calls get_content_metrics RPC</done>
</task>

<task type="auto">
  <name>Task 2: Add getContentPerformanceList function</name>
  <files>src/services/contentAnalyticsService.js</files>
  <action>
Add function after getContentMetrics:

```javascript
/**
 * Get content performance list sorted by total view time
 * @param {string} dateRange - Date range preset
 * @param {number} limit - Max items to return
 * @returns {Promise<Array>} Content performance list
 */
export async function getContentPerformanceList(dateRange = '7d', limit = 20) {
  const tenantId = await getEffectiveOwnerId();
  if (!tenantId) throw new Error('No tenant context');

  const { fromTs, toTs } = getDateRange(dateRange);

  const { data, error } = await supabase.rpc('get_content_performance_list', {
    p_tenant_id: tenantId,
    p_from_ts: fromTs,
    p_to_ts: toTs,
    p_limit: limit,
  });

  if (error) throw error;
  return data || [];
}
```

This provides the data for ANA-03 (content sorted by total view time).
  </action>
  <verify>Check function exists: `grep -A 5 'getContentPerformanceList' src/services/contentAnalyticsService.js | head -10`</verify>
  <done>getContentPerformanceList function exported and calls get_content_performance_list RPC</done>
</task>

<task type="auto">
  <name>Task 3: Add getViewingHeatmap function</name>
  <files>src/services/contentAnalyticsService.js</files>
  <action>
Add function after getContentPerformanceList:

```javascript
/**
 * Get viewing pattern heatmap data
 * @param {string} dateRange - Date range preset
 * @param {string} timezone - IANA timezone (default: browser timezone)
 * @returns {Promise<Array>} Heatmap data (168 cells: 7 days x 24 hours)
 */
export async function getViewingHeatmap(dateRange = '7d', timezone = null) {
  const tenantId = await getEffectiveOwnerId();
  if (!tenantId) throw new Error('No tenant context');

  const { fromTs, toTs } = getDateRange(dateRange);

  // Use browser timezone if not specified
  const tz = timezone || Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';

  const { data, error } = await supabase.rpc('get_viewing_heatmap', {
    p_tenant_id: tenantId,
    p_from_ts: fromTs,
    p_to_ts: toTs,
    p_timezone: tz,
  });

  if (error) throw error;
  return data || [];
}
```

Key notes:
- Browser timezone detection via Intl.DateTimeFormat()
- Fallback to 'UTC' if detection fails
- Returns array of 168 objects (7x24 grid) per RESEARCH.md
  </action>
  <verify>Check function exists: `grep -A 10 'getViewingHeatmap' src/services/contentAnalyticsService.js | head -15`</verify>
  <done>getViewingHeatmap function exported with browser timezone detection</done>
</task>

</tasks>

<verification>
- [ ] contentAnalyticsService.js contains getContentMetrics function
- [ ] contentAnalyticsService.js contains getContentPerformanceList function
- [ ] contentAnalyticsService.js contains getViewingHeatmap function
- [ ] All functions use existing patterns (getEffectiveOwnerId, getDateRange)
- [ ] getViewingHeatmap detects browser timezone
- [ ] No lint errors in the file
</verification>

<success_criteria>
1. All 3 functions are exported from contentAnalyticsService.js
2. Functions call corresponding RPCs from migration 118
3. Error handling follows existing patterns (throw on error)
4. Default values provided for empty results
</success_criteria>

<output>
After completion, create `.planning/phases/10-analytics/10-02-SUMMARY.md`
</output>
