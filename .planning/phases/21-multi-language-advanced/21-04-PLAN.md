---
phase: 21-multi-language-advanced
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/unit/services/translationService.test.js
  - tests/unit/services/languageService.test.js
  - tests/unit/components/ScreenGroupSettingsTab.test.jsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "translationService functions have unit test coverage"
    - "languageService location mapping functions have unit test coverage"
    - "ScreenGroupSettingsTab component has basic rendering test"
  artifacts:
    - path: "tests/unit/services/translationService.test.js"
      provides: "Unit tests for translation service"
      min_lines: 100
    - path: "tests/unit/services/languageService.test.js"
      provides: "Unit tests for language service location mapping"
      min_lines: 80
    - path: "tests/unit/components/ScreenGroupSettingsTab.test.jsx"
      provides: "Component test for settings tab"
      min_lines: 50
  key_links:
    - from: "tests/unit/services/translationService.test.js"
      to: "src/services/translationService.js"
      via: "import"
      pattern: "import.*translationService"
    - from: "tests/unit/services/languageService.test.js"
      to: "src/services/languageService.js"
      via: "import"
      pattern: "import.*languageService"
---

<objective>
Add test coverage for Phase 21 multi-language features to close TECH-04 verification gap.

Purpose: Address verification failure "New multi-language features have comprehensive test coverage" by adding unit tests for core service functions and a basic component test.

Output: Three test files covering translationService, languageService location mapping, and ScreenGroupSettingsTab component.
</objective>

<execution_context>
@/Users/massimodamico/.claude/get-shit-done/workflows/execute-plan.md
@/Users/massimodamico/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Phase 21 service files:
@src/services/translationService.js
@src/services/languageService.js

Existing test patterns:
@tests/unit/services/screenGroupService.test.js
@tests/setup.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create translationService unit tests</name>
  <files>tests/unit/services/translationService.test.js</files>
  <action>
Create unit tests for translationService.js following the established pattern in screenGroupService.test.js.

Mock the supabase module at the top with vi.mock before importing the service.

Test these functions:
1. **fetchTranslationDashboard**
   - Test it calls RPC with correct parameters (status filter, language filter)
   - Test it returns empty array when no data
   - Test it returns data from RPC
   - Test it throws when RPC errors

2. **bulkUpdateStatus**
   - Test it throws for invalid status (not in draft/review/approved)
   - Test it throws for empty sceneIds array
   - Test it calls RPC with correct parameters
   - Test it returns count from RPC

3. **updateSceneStatus**
   - Test it throws for invalid status
   - Test it calls supabase.from('scenes').update with correct params
   - Test it returns updated scene data

4. **getAiTranslationSuggestion**
   - Test it calls fetch with correct URL and body
   - Test it throws on non-ok response
   - Test it returns parsed JSON on success

5. **Constants export**
   - Test TRANSLATION_STATUSES has correct values
   - Test STATUS_LABELS has correct mappings
   - Test STATUS_COLORS has correct mappings

Use vi.fn() for mocks and follow the async import pattern from existing tests.
  </action>
  <verify>npm run test:unit -- tests/unit/services/translationService.test.js</verify>
  <done>All translationService tests pass, covering fetchTranslationDashboard, bulkUpdateStatus, updateSceneStatus, getAiTranslationSuggestion, and constant exports</done>
</task>

<task type="auto">
  <name>Task 2: Create languageService location mapping tests</name>
  <files>tests/unit/services/languageService.test.js</files>
  <action>
Create unit tests for languageService.js location mapping functions. These are pure functions that don't need database mocking.

Test these functions:
1. **LOCATION_LANGUAGE_MAP constant**
   - Test it has expected country codes (US, ES, FR, DE, etc.)
   - Test mappings are correct (US -> en, ES -> es, FR -> fr)

2. **getLanguageForLocation**
   - Test it returns correct language for known locations (US -> en, ES -> es, FR -> fr, DE -> de)
   - Test it returns 'en' for null/undefined input
   - Test it returns 'en' for unknown location codes
   - Test it handles lowercase input (converts to uppercase)

3. **getAvailableLocations**
   - Test it returns an array
   - Test each item has code and name properties
   - Test it's sorted alphabetically by name
   - Test it includes expected countries (Argentina, Australia, Germany, etc.)

4. **getLanguageColor**
   - Test it returns correct color for known languages (en, es, fr)
   - Test it returns gray fallback for unknown codes

5. **getSupportedLanguages**
   - Test it returns array with code, name, nativeName properties
   - Test it includes expected languages

Note: These tests don't require supabase mocking since the location mapping functions are pure. Only mock supabase if testing database operations.
  </action>
  <verify>npm run test:unit -- tests/unit/services/languageService.test.js</verify>
  <done>All languageService location mapping tests pass, covering LOCATION_LANGUAGE_MAP, getLanguageForLocation, getAvailableLocations, getLanguageColor, and getSupportedLanguages</done>
</task>

<task type="auto">
  <name>Task 3: Create ScreenGroupSettingsTab component test</name>
  <files>tests/unit/components/ScreenGroupSettingsTab.test.jsx</files>
  <action>
Create a basic component test for ScreenGroupSettingsTab following DashboardPage.test.jsx patterns.

Mock dependencies:
- Mock '../../../src/services/screenGroupService' with vi.mock
- Mock '../../../src/services/languageService' with vi.mock (getAvailableLocations, getSupportedLanguages, getLanguageForLocation)
- Mock '../../../src/contexts/AuthContext' for useAuth

Test cases:
1. **Renders without crashing**
   - Render with required props (groupId, groupSettings, onSave)
   - Verify component renders (no crash)

2. **Displays language dropdown**
   - Render component
   - Verify language dropdown/select exists with test-id or label

3. **Displays location dropdown**
   - Render component
   - Verify location dropdown/select exists

4. **Shows suggested language when location selected**
   - Mock getLanguageForLocation to return 'es'
   - Verify suggestion UI appears (or is ready to appear on selection)

5. **Calls onSave when save clicked**
   - Render with mocked onSave
   - Find and click save button
   - Verify onSave was called

Use @testing-library/react for rendering and assertions. Wrap in BrowserRouter if component uses router.
  </action>
  <verify>npm run test:unit -- tests/unit/components/ScreenGroupSettingsTab.test.jsx</verify>
  <done>ScreenGroupSettingsTab component test passes, verifying rendering, dropdowns, and save functionality</done>
</task>

</tasks>

<verification>
Run all Phase 21 tests:
```bash
npm run test:unit -- tests/unit/services/translationService.test.js tests/unit/services/languageService.test.js tests/unit/components/ScreenGroupSettingsTab.test.jsx
```

Expected: All tests pass with no failures.
</verification>

<success_criteria>
1. translationService.test.js exists with 100+ lines testing all major functions
2. languageService.test.js exists with 80+ lines testing location mapping
3. ScreenGroupSettingsTab.test.jsx exists with 50+ lines testing component rendering
4. All tests pass when run individually and together
5. Tests follow established patterns from existing test files
</success_criteria>

<output>
After completion, create `.planning/phases/21-multi-language-advanced/21-04-SUMMARY.md`
</output>
