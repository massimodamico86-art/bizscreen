---
phase: 03-auth-hardening
plan: 03
type: execute
wave: 2
depends_on: ["03-02"]
files_modified:
  - src/services/rateLimitService.js
  - src/services/mediaService.js
  - src/services/sceneService.js
autonomous: true

must_haves:
  truths:
    - "Media upload returns 429 after 50 requests in 15 minutes"
    - "Scene creation returns 429 after 30 requests in 15 minutes"
    - "Rate limit errors include retry time information"
    - "Authenticated users get 2x the anonymous rate limit"
  artifacts:
    - path: "src/services/rateLimitService.js"
      provides: "Rate limit service wrapper"
      exports: ["checkRateLimit", "RATE_LIMITS"]
    - path: "src/services/mediaService.js"
      provides: "Rate-limited media upload"
      contains: "checkRateLimit"
    - path: "src/services/sceneService.js"
      provides: "Rate-limited scene creation"
      contains: "checkRateLimit"
  key_links:
    - from: "src/services/mediaService.js"
      to: "src/services/rateLimitService.js"
      via: "import checkRateLimit"
      pattern: "import.*checkRateLimit.*rateLimitService"
    - from: "src/services/rateLimitService.js"
      to: "supabase.rpc('check_rate_limit')"
      via: "RPC call"
      pattern: "supabase\\.rpc.*check_rate_limit"
---

<objective>
Integrate rate limiting into high-frequency API services

Purpose: Apply rate limits to media upload and scene creation endpoints as identified in research. Uses the database function from Plan 02. Authenticated users get 2x limits as recommended in research.

Output: Media upload and scene creation enforce rate limits, returning descriptive errors when exceeded.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-auth-hardening/03-CONTEXT.md
@.planning/phases/03-auth-hardening/03-RESEARCH.md
@.planning/phases/03-auth-hardening/03-02-SUMMARY.md
@src/services/mediaService.js
@src/services/sceneService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rate limit service wrapper</name>
  <files>src/services/rateLimitService.js</files>
  <action>
Create src/services/rateLimitService.js:

```javascript
/**
 * Rate Limit Service - Wrapper for database rate limiting
 *
 * Provides rate limiting for high-frequency API endpoints.
 * Uses PostgreSQL check_rate_limit() function for atomic checks.
 */

import { supabase } from '../lib/supabase';

/**
 * Rate limit configurations per action
 * Authenticated users get 2x the base limit
 */
export const RATE_LIMITS = {
  media_upload: { base: 50, window: 15 },
  scene_create: { base: 30, window: 15 },
  ai_generation: { base: 20, window: 15 },
};

/**
 * Check rate limit for an action
 * @param {string} action - Action type (e.g., 'media_upload')
 * @param {Object} options - Options
 * @param {string} options.userId - User ID (optional, uses IP if not provided)
 * @param {boolean} options.isAuthenticated - Whether user is authenticated (2x limit)
 * @returns {Promise<{allowed: boolean, retryAfter?: number, remaining?: number}>}
 */
export async function checkRateLimit(action, options = {}) {
  const config = RATE_LIMITS[action];
  if (!config) {
    console.warn(`Unknown rate limit action: ${action}`);
    return { allowed: true }; // Fail open for unknown actions
  }

  // Use user ID if authenticated, otherwise use a session identifier
  // In production, you'd get the real IP from headers
  const { userId, isAuthenticated = false } = options;
  const identifier = userId || 'anonymous';

  // Authenticated users get 2x the limit
  const maxRequests = isAuthenticated ? config.base * 2 : config.base;

  try {
    const { data, error } = await supabase.rpc('check_rate_limit', {
      p_identifier: identifier,
      p_action: action,
      p_max_requests: maxRequests,
      p_window_minutes: config.window,
    });

    if (error) {
      console.error('Rate limit check error:', error);
      // Fail open - don't block users if rate limit check fails
      return { allowed: true };
    }

    if (!data.allowed) {
      return {
        allowed: false,
        retryAfter: data.retry_after_seconds,
        currentCount: data.current_count,
        limit: data.limit,
      };
    }

    return {
      allowed: true,
      remaining: data.remaining,
      limit: data.limit,
    };
  } catch (err) {
    console.error('Rate limit check exception:', err);
    // Fail open
    return { allowed: true };
  }
}

/**
 * Create a rate limit error with standard format
 * @param {number} retryAfter - Seconds until rate limit resets
 * @returns {Error}
 */
export function createRateLimitError(retryAfter) {
  const minutes = Math.ceil(retryAfter / 60);
  const error = new Error(
    `Too many requests. Please try again in ${minutes} minute${minutes > 1 ? 's' : ''}.`
  );
  error.code = 'RATE_LIMIT_EXCEEDED';
  error.retryAfter = retryAfter;
  return error;
}

export default {
  checkRateLimit,
  createRateLimitError,
  RATE_LIMITS,
};
```
  </action>
  <verify>
  - File exists: `ls src/services/rateLimitService.js`
  - Exports checkRateLimit: `grep "export async function checkRateLimit" src/services/rateLimitService.js`
  - Uses supabase.rpc: `grep "supabase.rpc.*check_rate_limit" src/services/rateLimitService.js`
  </verify>
  <done>Rate limit service wrapper created with checkRateLimit function</done>
</task>

<task type="auto">
  <name>Task 2: Add rate limiting to media upload</name>
  <files>src/services/mediaService.js</files>
  <action>
Update src/services/mediaService.js to add rate limiting to upload functions:

1. Add import at top of file (after other imports):
```javascript
import { checkRateLimit, createRateLimitError } from './rateLimitService.js';
```

2. Find the `createMediaAsset` function (around line 137) and add rate limit check at the start:

```javascript
export async function createMediaAsset({
  name,
  filename,
  type,
  mimeType,
  size,
  url,
  thumbnailUrl = null,
  metadata = {},
  tags = [],
  folderId = null,
}) {
  // Rate limit check
  const { data: { user } } = await supabase.auth.getUser();
  const rateCheck = await checkRateLimit('media_upload', {
    userId: user?.id,
    isAuthenticated: !!user,
  });

  if (!rateCheck.allowed) {
    throw createRateLimitError(rateCheck.retryAfter);
  }

  // ... rest of existing function unchanged
```

3. Also add to `uploadMediaFromDataUrl` function (around line 185):

Find the function and add after the initial setup:
```javascript
export async function uploadMediaFromDataUrl(dataUrl, options = {}) {
  // Rate limit check
  const { data: { user } } = await supabase.auth.getUser();
  const rateCheck = await checkRateLimit('media_upload', {
    userId: user?.id,
    isAuthenticated: !!user,
  });

  if (!rateCheck.allowed) {
    throw createRateLimitError(rateCheck.retryAfter);
  }

  // ... rest of existing function unchanged
```

IMPORTANT: Only add the rate limit check, do NOT modify any other logic in the functions.
  </action>
  <verify>
  - Import added: `grep "import.*rateLimitService" src/services/mediaService.js`
  - createMediaAsset has rate check: `grep -A 10 "export async function createMediaAsset" src/services/mediaService.js | grep "checkRateLimit"`
  - uploadMediaFromDataUrl has rate check: `grep -A 10 "export async function uploadMediaFromDataUrl" src/services/mediaService.js | grep "checkRateLimit"`
  - Build succeeds: `npm run build 2>&1 | grep -i error || echo "Build OK"`
  </verify>
  <done>Media upload functions check rate limits before proceeding</done>
</task>

<task type="auto">
  <name>Task 3: Add rate limiting to scene creation</name>
  <files>src/services/sceneService.js</files>
  <action>
Update src/services/sceneService.js to add rate limiting to createScene:

1. Add import at top of file (after other imports):
```javascript
import { checkRateLimit, createRateLimitError } from './rateLimitService.js';
```

2. Find the `createScene` function (around line 22) and add rate limit check at the start:

```javascript
export async function createScene({
  name,
  description = null,
  templateId = null,
  content = null,
}) {
  // Rate limit check
  const { data: { user } } = await supabase.auth.getUser();
  const rateCheck = await checkRateLimit('scene_create', {
    userId: user?.id,
    isAuthenticated: !!user,
  });

  if (!rateCheck.allowed) {
    throw createRateLimitError(rateCheck.retryAfter);
  }

  // ... rest of existing function unchanged
```

IMPORTANT: Only add the rate limit check, do NOT modify any other logic in the function.
  </action>
  <verify>
  - Import added: `grep "import.*rateLimitService" src/services/sceneService.js`
  - createScene has rate check: `grep -A 10 "export async function createScene" src/services/sceneService.js | grep "checkRateLimit"`
  - Build succeeds: `npm run build 2>&1 | grep -i error || echo "Build OK"`
  </verify>
  <done>Scene creation checks rate limit before proceeding</done>
</task>

</tasks>

<verification>
1. rateLimitService.js exists and exports checkRateLimit
2. mediaService.js imports and uses rateLimitService
3. sceneService.js imports and uses rateLimitService
4. Both services throw rate limit error with retryAfter info
5. Build completes without errors
</verification>

<success_criteria>
- Media upload blocked after 50 requests in 15 minutes (100 for authenticated)
- Scene creation blocked after 30 requests in 15 minutes (60 for authenticated)
- Rate limit errors include "try again in X minutes" message
- Rate limit errors have RATE_LIMIT_EXCEEDED code for UI handling
</success_criteria>

<output>
After completion, create `.planning/phases/03-auth-hardening/03-03-SUMMARY.md`
</output>
