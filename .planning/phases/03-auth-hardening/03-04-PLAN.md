---
phase: 03-auth-hardening
plan: 04
type: execute
wave: 3
depends_on: ["03-01", "03-02", "03-03"]
files_modified:
  - tests/unit/passwordValidation.test.js
  - tests/unit/rateLimitService.test.js
autonomous: true

must_haves:
  truths:
    - "Tests verify 6-char passwords are rejected"
    - "Tests verify 8-char passwords without complexity are rejected"
    - "Tests verify rate limit service returns correct structure"
    - "All tests pass"
  artifacts:
    - path: "tests/unit/passwordValidation.test.js"
      provides: "Password policy verification tests"
      min_lines: 30
    - path: "tests/unit/rateLimitService.test.js"
      provides: "Rate limit service tests"
      min_lines: 30
  key_links:
    - from: "tests/unit/passwordValidation.test.js"
      to: "src/services/passwordService.js"
      via: "import validatePassword"
      pattern: "import.*validatePassword.*passwordService"
    - from: "tests/unit/rateLimitService.test.js"
      to: "src/services/rateLimitService.js"
      via: "import checkRateLimit"
      pattern: "import.*checkRateLimit.*rateLimitService"
---

<objective>
Create verification tests for password policy and rate limiting

Purpose: Verify that the auth hardening implementation meets the roadmap success criteria. Tests document expected behavior and catch regressions.

Output: Test files that verify password validation rules and rate limit service behavior.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-auth-hardening/03-CONTEXT.md
@.planning/phases/03-auth-hardening/03-01-SUMMARY.md
@.planning/phases/03-auth-hardening/03-02-SUMMARY.md
@.planning/phases/03-auth-hardening/03-03-SUMMARY.md
@src/services/passwordService.js
@src/services/rateLimitService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create password validation tests</name>
  <files>tests/unit/passwordValidation.test.js</files>
  <action>
Create tests/unit/passwordValidation.test.js:

```javascript
/**
 * Password Validation Tests
 *
 * Verifies SEC-03: Password policy enforces minimum 8 characters with complexity
 *
 * Success criteria from ROADMAP.md:
 * 1. User cannot set password shorter than 8 characters
 * 2. User cannot set password without complexity (uppercase, lowercase, number)
 */

import { describe, it, expect } from 'vitest';
import { validatePassword, PASSWORD_REQUIREMENTS } from '../../src/services/passwordService.js';

describe('Password Validation - SEC-03', () => {
  describe('Length requirements', () => {
    it('rejects passwords shorter than 8 characters', () => {
      const result = validatePassword('Short1!');
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('8 characters'))).toBe(true);
    });

    it('accepts passwords with exactly 8 characters meeting all requirements', () => {
      const result = validatePassword('Abcdef1!');
      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('rejects passwords longer than 128 characters', () => {
      const longPassword = 'Aa1!' + 'x'.repeat(130);
      const result = validatePassword(longPassword);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('128'))).toBe(true);
    });

    it('accepts passwords at maximum length with requirements', () => {
      const maxPassword = 'Aa1!' + 'x'.repeat(124); // 128 chars total
      const result = validatePassword(maxPassword);
      expect(result.valid).toBe(true);
    });
  });

  describe('Complexity requirements', () => {
    it('rejects passwords without uppercase letter', () => {
      const result = validatePassword('abcdefg1!');
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('uppercase'))).toBe(true);
    });

    it('rejects passwords without lowercase letter', () => {
      const result = validatePassword('ABCDEFG1!');
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('lowercase'))).toBe(true);
    });

    it('rejects passwords without number', () => {
      const result = validatePassword('Abcdefgh!');
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('number'))).toBe(true);
    });

    it('rejects passwords without special character', () => {
      const result = validatePassword('Abcdefg1');
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('special'))).toBe(true);
    });

    it('accepts passwords meeting all complexity requirements', () => {
      const result = validatePassword('Abcdefg1!');
      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });
  });

  describe('Common password blocking', () => {
    it('rejects common passwords like "password"', () => {
      const result = validatePassword('Password1!');
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('common'))).toBe(true);
    });

    it('rejects common passwords regardless of case', () => {
      const result = validatePassword('PASSWORD1!');
      expect(result.valid).toBe(false);
    });
  });

  describe('Email inclusion check', () => {
    it('rejects passwords containing email username', () => {
      const result = validatePassword('JohnDoe1!xyz', 'johndoe@example.com');
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('email'))).toBe(true);
    });

    it('accepts passwords not containing email parts', () => {
      const result = validatePassword('Secure99!', 'johndoe@example.com');
      expect(result.valid).toBe(true);
    });
  });

  describe('Password strength scoring', () => {
    it('gives higher score to longer passwords', () => {
      const short = validatePassword('Abcdef1!');   // 8 chars
      const medium = validatePassword('Abcdefghij1!'); // 12 chars
      const long = validatePassword('Abcdefghijklmnop1!'); // 18 chars

      expect(medium.score).toBeGreaterThan(short.score);
      expect(long.score).toBeGreaterThan(medium.score);
    });

    it('reduces score for sequential characters', () => {
      const noSeq = validatePassword('Xyzpqr12!');
      const hasSeq = validatePassword('Abcdef12!');

      // Sequential "abc" reduces score
      expect(hasSeq.score).toBeLessThanOrEqual(noSeq.score);
    });
  });

  describe('Requirements configuration', () => {
    it('has correct minimum length configured', () => {
      expect(PASSWORD_REQUIREMENTS.minLength).toBe(8);
    });

    it('has correct maximum length configured', () => {
      expect(PASSWORD_REQUIREMENTS.maxLength).toBe(128);
    });

    it('requires uppercase letters', () => {
      expect(PASSWORD_REQUIREMENTS.requireUppercase).toBe(true);
    });

    it('requires lowercase letters', () => {
      expect(PASSWORD_REQUIREMENTS.requireLowercase).toBe(true);
    });

    it('requires numbers', () => {
      expect(PASSWORD_REQUIREMENTS.requireNumber).toBe(true);
    });

    it('requires special characters', () => {
      expect(PASSWORD_REQUIREMENTS.requireSpecial).toBe(true);
    });
  });
});
```
  </action>
  <verify>
  - File exists: `ls tests/unit/passwordValidation.test.js`
  - Tests run: `npm test -- tests/unit/passwordValidation.test.js 2>&1 | tail -20`
  - Tests pass: `npm test -- tests/unit/passwordValidation.test.js`
  </verify>
  <done>Password validation tests verify all complexity requirements</done>
</task>

<task type="auto">
  <name>Task 2: Create rate limit service tests</name>
  <files>tests/unit/rateLimitService.test.js</files>
  <action>
Create tests/unit/rateLimitService.test.js:

```javascript
/**
 * Rate Limit Service Tests
 *
 * Verifies SEC-04: Global API rate limiting protects high-frequency endpoints
 *
 * Success criteria from ROADMAP.md:
 * 3. High-frequency API endpoints return 429 after exceeding rate limit
 * 4. Rate limiting applies per-user and per-IP dimensions
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { checkRateLimit, createRateLimitError, RATE_LIMITS } from '../../src/services/rateLimitService.js';

// Mock Supabase
vi.mock('../../src/lib/supabase', () => ({
  supabase: {
    rpc: vi.fn(),
  },
}));

import { supabase } from '../../src/lib/supabase';

describe('Rate Limit Service - SEC-04', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('RATE_LIMITS configuration', () => {
    it('defines media_upload limit (50 per 15 min)', () => {
      expect(RATE_LIMITS.media_upload).toEqual({ base: 50, window: 15 });
    });

    it('defines scene_create limit (30 per 15 min)', () => {
      expect(RATE_LIMITS.scene_create).toEqual({ base: 30, window: 15 });
    });

    it('defines ai_generation limit (20 per 15 min)', () => {
      expect(RATE_LIMITS.ai_generation).toEqual({ base: 20, window: 15 });
    });
  });

  describe('checkRateLimit', () => {
    it('returns allowed: true when under limit', async () => {
      supabase.rpc.mockResolvedValueOnce({
        data: { allowed: true, current_count: 5, remaining: 45, limit: 50 },
        error: null,
      });

      const result = await checkRateLimit('media_upload', { userId: 'user-123' });

      expect(result.allowed).toBe(true);
      expect(result.remaining).toBe(45);
    });

    it('returns allowed: false when over limit', async () => {
      supabase.rpc.mockResolvedValueOnce({
        data: { allowed: false, current_count: 50, retry_after_seconds: 300, limit: 50 },
        error: null,
      });

      const result = await checkRateLimit('media_upload', { userId: 'user-123' });

      expect(result.allowed).toBe(false);
      expect(result.retryAfter).toBe(300);
    });

    it('uses 2x limit for authenticated users', async () => {
      supabase.rpc.mockResolvedValueOnce({
        data: { allowed: true, current_count: 1, remaining: 99, limit: 100 },
        error: null,
      });

      await checkRateLimit('media_upload', { userId: 'user-123', isAuthenticated: true });

      expect(supabase.rpc).toHaveBeenCalledWith('check_rate_limit', {
        p_identifier: 'user-123',
        p_action: 'media_upload',
        p_max_requests: 100, // 50 * 2 for authenticated
        p_window_minutes: 15,
      });
    });

    it('uses base limit for anonymous users', async () => {
      supabase.rpc.mockResolvedValueOnce({
        data: { allowed: true, current_count: 1, remaining: 49, limit: 50 },
        error: null,
      });

      await checkRateLimit('media_upload', { isAuthenticated: false });

      expect(supabase.rpc).toHaveBeenCalledWith('check_rate_limit', {
        p_identifier: 'anonymous',
        p_action: 'media_upload',
        p_max_requests: 50, // base limit
        p_window_minutes: 15,
      });
    });

    it('fails open on RPC error', async () => {
      supabase.rpc.mockResolvedValueOnce({
        data: null,
        error: { message: 'Database error' },
      });

      const result = await checkRateLimit('media_upload', { userId: 'user-123' });

      expect(result.allowed).toBe(true); // Fail open
    });

    it('fails open on exception', async () => {
      supabase.rpc.mockRejectedValueOnce(new Error('Network error'));

      const result = await checkRateLimit('media_upload', { userId: 'user-123' });

      expect(result.allowed).toBe(true); // Fail open
    });

    it('fails open for unknown actions', async () => {
      const result = await checkRateLimit('unknown_action', { userId: 'user-123' });

      expect(result.allowed).toBe(true);
      expect(supabase.rpc).not.toHaveBeenCalled();
    });
  });

  describe('createRateLimitError', () => {
    it('creates error with correct message for seconds', () => {
      const error = createRateLimitError(45);
      expect(error.message).toBe('Too many requests. Please try again in 1 minute.');
      expect(error.code).toBe('RATE_LIMIT_EXCEEDED');
      expect(error.retryAfter).toBe(45);
    });

    it('creates error with correct message for minutes', () => {
      const error = createRateLimitError(300);
      expect(error.message).toBe('Too many requests. Please try again in 5 minutes.');
    });

    it('uses singular "minute" for 1 minute', () => {
      const error = createRateLimitError(60);
      expect(error.message).toContain('1 minute.');
    });

    it('uses plural "minutes" for multiple minutes', () => {
      const error = createRateLimitError(120);
      expect(error.message).toContain('2 minutes.');
    });
  });

  describe('per-user dimension', () => {
    it('uses userId as identifier when provided', async () => {
      supabase.rpc.mockResolvedValueOnce({
        data: { allowed: true, current_count: 1, remaining: 49, limit: 50 },
        error: null,
      });

      await checkRateLimit('media_upload', { userId: 'specific-user-id' });

      expect(supabase.rpc).toHaveBeenCalledWith('check_rate_limit',
        expect.objectContaining({ p_identifier: 'specific-user-id' })
      );
    });
  });

  describe('per-IP dimension fallback', () => {
    it('uses anonymous identifier when userId not provided', async () => {
      supabase.rpc.mockResolvedValueOnce({
        data: { allowed: true, current_count: 1, remaining: 49, limit: 50 },
        error: null,
      });

      await checkRateLimit('media_upload', {});

      expect(supabase.rpc).toHaveBeenCalledWith('check_rate_limit',
        expect.objectContaining({ p_identifier: 'anonymous' })
      );
    });
  });
});
```
  </action>
  <verify>
  - File exists: `ls tests/unit/rateLimitService.test.js`
  - Tests run: `npm test -- tests/unit/rateLimitService.test.js 2>&1 | tail -20`
  - Tests pass: `npm test -- tests/unit/rateLimitService.test.js`
  </verify>
  <done>Rate limit service tests verify configuration and behavior</done>
</task>

<task type="auto">
  <name>Task 3: Run full test suite and verify</name>
  <files></files>
  <action>
Run the complete test suite to ensure no regressions:

```bash
npm test
```

Verify that:
1. All new tests pass
2. Existing tests still pass
3. No new test failures introduced

Document test counts in summary.
  </action>
  <verify>
  - `npm test` exits with code 0
  - New test files appear in test output
  </verify>
  <done>All tests pass, no regressions</done>
</task>

</tasks>

<verification>
1. tests/unit/passwordValidation.test.js exists and passes
2. tests/unit/rateLimitService.test.js exists and passes
3. Full test suite passes with no regressions
4. Test coverage includes all success criteria from roadmap
</verification>

<success_criteria>
- Password validation tests verify:
  - 8-char minimum enforced
  - Complexity (uppercase, lowercase, number) required
  - Common passwords blocked
- Rate limit tests verify:
  - Configuration matches spec (50/30/20 per 15 min)
  - Authenticated users get 2x limit
  - Fail-open behavior on errors
  - Error messages include retry time
</success_criteria>

<output>
After completion, create `.planning/phases/03-auth-hardening/03-04-SUMMARY.md`
</output>
