---
phase: 11-gdpr-compliance
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/120_gdpr_deletion_execution.sql
autonomous: true

must_haves:
  truths:
    - "RPC executes deletion for accounts past 30-day grace period"
    - "External media URLs collected before database cascade delete"
    - "Deletion stages: get_urls -> delete_external -> delete_db -> log_completion"
    - "Deletion status updated through processing -> completed stages"
  artifacts:
    - path: "supabase/migrations/120_gdpr_deletion_execution.sql"
      provides: "execute_scheduled_deletions and get_media_urls_for_user RPC functions"
      contains: "CREATE OR REPLACE FUNCTION execute_scheduled_deletions"
  key_links:
    - from: "execute_scheduled_deletions"
      to: "account_deletion_requests"
      via: "SELECT WHERE status = 'scheduled' AND scheduled_deletion_at <= NOW()"
      pattern: "scheduled_deletion_at.*<=.*NOW"
---

<objective>
Create database RPC functions for account deletion execution

Purpose: GDPR Article 17 requires right to erasure - when grace period ends, all user data must be permanently deleted. This RPC handles the database-side deletion with proper staging.

Output: Migration file with deletion execution functions that handle staged deletion process
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-gdpr-compliance/11-RESEARCH.md

# Existing GDPR infrastructure
@supabase/migrations/106_gdpr_compliance.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create media URL collection function</name>
  <files>supabase/migrations/120_gdpr_deletion_execution.sql</files>
  <action>
Create migration file with get_media_urls_for_user(p_user_id UUID) function.

Critical: This function MUST be called BEFORE deleting database records, because CASCADE delete will remove the URLs we need to delete from S3/Cloudinary.

The function should:
1. Accept p_user_id parameter
2. Query media_assets for all URLs where owner_id = p_user_id
3. Return JSONB array with:
   - id (for logging)
   - url (the S3/Cloudinary URL)
   - thumbnail_url (if exists)
   - type (image/video/etc for determining S3 vs Cloudinary)

```sql
CREATE OR REPLACE FUNCTION get_media_urls_for_user(p_user_id UUID)
RETURNS JSONB
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT COALESCE(
    jsonb_agg(jsonb_build_object(
      'id', id,
      'url', url,
      'thumbnailUrl', thumbnail_url,
      'type', type
    )),
    '[]'::jsonb
  )
  FROM media_assets
  WHERE owner_id = p_user_id;
$$;
```

Grant EXECUTE to service_role only.
  </action>
  <verify>
Function exists and returns array of media URLs for user
  </verify>
  <done>
Media URL collection function created that captures all external file references before deletion
  </done>
</task>

<task type="auto">
  <name>Task 2: Create deletion execution function</name>
  <files>supabase/migrations/120_gdpr_deletion_execution.sql</files>
  <action>
Add execute_account_deletion(p_request_id UUID) function to the migration.

This function handles the database-side deletion:

1. Validate request exists and status is 'scheduled'
2. Check scheduled_deletion_at <= NOW()
3. Update status to 'processing'
4. Get user_id from request
5. Note: External deletions (S3/Cloudinary) handled by calling code BEFORE this
6. Delete user from auth.users (which cascades to profiles and all owned data)
7. Update request status to 'completed' with completed_at timestamp
8. Return success/failure with details

```sql
CREATE OR REPLACE FUNCTION execute_account_deletion(p_request_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_request RECORD;
  v_result JSONB;
BEGIN
  -- Get and lock the request
  SELECT * INTO v_request
  FROM account_deletion_requests
  WHERE id = p_request_id
  FOR UPDATE;

  IF v_request IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Request not found');
  END IF;

  IF v_request.status != 'scheduled' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Request not in scheduled status');
  END IF;

  IF v_request.scheduled_deletion_at > NOW() THEN
    RETURN jsonb_build_object('success', false, 'error', 'Grace period not complete');
  END IF;

  -- Mark as processing
  UPDATE account_deletion_requests
  SET status = 'processing'
  WHERE id = p_request_id;

  -- Delete user (CASCADE handles all owned data)
  -- Note: auth.admin.deleteUser must be called from Edge Function
  -- This function just prepares and logs

  -- Mark as ready for auth deletion
  UPDATE account_deletion_requests
  SET status = 'processing',
      completed_at = NOW()
  WHERE id = p_request_id;

  RETURN jsonb_build_object(
    'success', true,
    'userId', v_request.user_id,
    'email', v_request.email
  );
END;
$$;
```

Also add function to get pending deletions:
```sql
CREATE OR REPLACE FUNCTION get_pending_deletions()
RETURNS TABLE (
  id UUID,
  user_id UUID,
  email TEXT,
  scheduled_deletion_at TIMESTAMPTZ,
  reason TEXT
)
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT id, user_id, email, scheduled_deletion_at, reason
  FROM account_deletion_requests
  WHERE status = 'scheduled'
    AND scheduled_deletion_at <= NOW()
  ORDER BY scheduled_deletion_at ASC
  LIMIT 10;
$$;
```

Grant both functions to service_role only.
  </action>
  <verify>
Functions exist:
- get_pending_deletions returns due deletion requests
- execute_account_deletion processes a single request
  </verify>
  <done>
Deletion execution functions created with proper staging (get_urls -> process -> complete) and row locking for concurrency safety
  </done>
</task>

<task type="auto">
  <name>Task 3: Add deletion audit logging</name>
  <files>supabase/migrations/120_gdpr_deletion_execution.sql</files>
  <action>
Add gdpr_audit_log table and logging function for GDPR accountability.

```sql
-- GDPR deletion audit trail (required for compliance)
CREATE TABLE IF NOT EXISTS gdpr_audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_type TEXT NOT NULL CHECK (event_type IN ('deletion_started', 'external_deleted', 'db_deleted', 'deletion_completed', 'deletion_failed')),
  user_id UUID, -- May be null after deletion
  email TEXT NOT NULL, -- Preserved for audit
  request_id UUID REFERENCES account_deletion_requests(id) ON DELETE SET NULL,
  details JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_gdpr_audit_email ON gdpr_audit_log(email);
CREATE INDEX IF NOT EXISTS idx_gdpr_audit_created ON gdpr_audit_log(created_at DESC);

-- Retain for 1 year per GDPR accountability requirements
COMMENT ON TABLE gdpr_audit_log IS 'GDPR Article 5(2) accountability - deletion audit trail retained 1 year';
```

Add logging function:
```sql
CREATE OR REPLACE FUNCTION log_gdpr_event(
  p_event_type TEXT,
  p_user_id UUID,
  p_email TEXT,
  p_request_id UUID,
  p_details JSONB DEFAULT NULL
)
RETURNS UUID
LANGUAGE sql
SECURITY DEFINER
AS $$
  INSERT INTO gdpr_audit_log (event_type, user_id, email, request_id, details)
  VALUES (p_event_type, p_user_id, p_email, p_request_id, p_details)
  RETURNING id;
$$;
```

Grant to service_role.
  </action>
  <verify>
- gdpr_audit_log table exists with proper schema
- log_gdpr_event function exists
- Indexes on email and created_at
  </verify>
  <done>
GDPR audit logging infrastructure created for deletion accountability and compliance verification
  </done>
</task>

</tasks>

<verification>
- [ ] Migration file 120_gdpr_deletion_execution.sql exists
- [ ] get_media_urls_for_user function returns all media URLs for a user
- [ ] get_pending_deletions function returns due deletion requests
- [ ] execute_account_deletion function processes deletion with proper staging
- [ ] gdpr_audit_log table created with appropriate event types
- [ ] log_gdpr_event function for audit trail
- [ ] All functions have SECURITY DEFINER and service_role GRANT
- [ ] Row locking (FOR UPDATE) prevents race conditions
</verification>

<success_criteria>
- get_pending_deletions() returns requests where scheduled_deletion_at <= NOW()
- get_media_urls_for_user(user_id) returns all S3/Cloudinary URLs before deletion
- execute_account_deletion(request_id) processes deletion with status updates
- Audit events logged for compliance verification
</success_criteria>

<output>
After completion, create `.planning/phases/11-gdpr-compliance/11-02-SUMMARY.md`
</output>
