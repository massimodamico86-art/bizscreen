---
phase: 11-gdpr-compliance
plan: 08
type: execute
wave: 5
depends_on: ["11-01", "11-02", "11-03", "11-04", "11-05", "11-06", "11-07"]
files_modified:
  - tests/unit/gdprService.test.js
  - tests/unit/gdprDeletionService.test.js
autonomous: true

must_haves:
  truths:
    - "Unit tests verify URL parsing for S3 and Cloudinary"
    - "Unit tests verify export data structure"
    - "Unit tests verify deletion service functions"
    - "Tests cover error handling paths"
  artifacts:
    - path: "tests/unit/gdprService.test.js"
      provides: "Tests for gdprService functions"
      min_lines: 100
    - path: "tests/unit/gdprDeletionService.test.js"
      provides: "Tests for gdprDeletionService functions"
      min_lines: 80
  key_links:
    - from: "tests/unit/gdprDeletionService.test.js"
      to: "src/services/gdprDeletionService.js"
      via: "import and test cases"
      pattern: "import.*from.*gdprDeletionService"
---

<objective>
Create unit tests for GDPR service functions

Purpose: Verify GDPR compliance features work correctly before deployment. Tests focus on URL parsing, data structure validation, and error handling.

Output: Test files covering gdprService and gdprDeletionService functions
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-gdpr-compliance/11-RESEARCH.md

# Services to test
@src/services/gdprService.js
@src/services/gdprDeletionService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gdprDeletionService tests</name>
  <files>tests/unit/gdprDeletionService.test.js</files>
  <action>
Create test file for gdprDeletionService focusing on URL parsing utilities.

```javascript
/**
 * Tests for GDPR Deletion Service
 *
 * Verifies URL parsing and media categorization for S3/Cloudinary deletion.
 */

import { describe, it, expect } from 'vitest';
import {
  parseMediaUrl,
  categorizeMediaUrls,
} from '../../src/services/gdprDeletionService.js';

describe('gdprDeletionService', () => {
  describe('parseMediaUrl', () => {
    describe('Cloudinary URLs', () => {
      it('should parse standard Cloudinary URL', () => {
        const url = 'https://res.cloudinary.com/demo/image/upload/v1234/folder/image.jpg';
        const result = parseMediaUrl(url);

        expect(result.provider).toBe('cloudinary');
        expect(result.key).toBe('folder/image');
      });

      it('should parse Cloudinary URL without version', () => {
        const url = 'https://res.cloudinary.com/demo/image/upload/folder/subfolder/image.png';
        const result = parseMediaUrl(url);

        expect(result.provider).toBe('cloudinary');
        expect(result.key).toBe('folder/subfolder/image');
      });

      it('should handle Cloudinary URL with transformations', () => {
        const url = 'https://res.cloudinary.com/demo/image/upload/c_fill,w_100/v1234/folder/image.jpg';
        const result = parseMediaUrl(url);

        expect(result.provider).toBe('cloudinary');
        // Key extraction may vary based on transformation position
      });
    });

    describe('S3 URLs', () => {
      it('should parse S3 bucket-first URL format', () => {
        const url = 'https://mybucket.s3.us-east-1.amazonaws.com/uploads/user123/image.jpg';
        const result = parseMediaUrl(url);

        expect(result.provider).toBe('s3');
        expect(result.key).toBe('uploads/user123/image.jpg');
      });

      it('should parse S3 path-style URL format', () => {
        const url = 'https://s3.us-east-1.amazonaws.com/mybucket/uploads/file.png';
        const result = parseMediaUrl(url);

        expect(result.provider).toBe('s3');
        expect(result.key).toBe('mybucket/uploads/file.png');
      });

      it('should handle S3 URL with special characters', () => {
        const url = 'https://mybucket.s3.amazonaws.com/uploads/file%20name.jpg';
        const result = parseMediaUrl(url);

        expect(result.provider).toBe('s3');
        expect(result.key).toContain('uploads/');
      });
    });

    describe('Unknown URLs', () => {
      it('should return unknown for null URL', () => {
        const result = parseMediaUrl(null);
        expect(result.provider).toBe('unknown');
        expect(result.key).toBeNull();
      });

      it('should return unknown for empty URL', () => {
        const result = parseMediaUrl('');
        expect(result.provider).toBe('unknown');
        expect(result.key).toBeNull();
      });

      it('should return unknown for non-cloud URL', () => {
        const url = 'https://example.com/images/photo.jpg';
        const result = parseMediaUrl(url);
        expect(result.provider).toBe('unknown');
      });

      it('should return unknown for data URLs', () => {
        const url = 'data:image/png;base64,iVBORw0KGgo...';
        const result = parseMediaUrl(url);
        expect(result.provider).toBe('unknown');
      });
    });
  });

  describe('categorizeMediaUrls', () => {
    it('should separate S3 and Cloudinary URLs', () => {
      const mediaItems = [
        { url: 'https://mybucket.s3.us-east-1.amazonaws.com/file1.jpg' },
        { url: 'https://res.cloudinary.com/demo/image/upload/v1/file2.jpg' },
        { url: 'https://mybucket.s3.us-east-1.amazonaws.com/file3.jpg' },
      ];

      const result = categorizeMediaUrls(mediaItems);

      expect(result.s3Keys).toHaveLength(2);
      expect(result.cloudinaryPublicIds).toHaveLength(1);
    });

    it('should include thumbnail URLs', () => {
      const mediaItems = [
        {
          url: 'https://mybucket.s3.amazonaws.com/image.jpg',
          thumbnailUrl: 'https://mybucket.s3.amazonaws.com/thumb.jpg',
        },
      ];

      const result = categorizeMediaUrls(mediaItems);

      expect(result.s3Keys).toHaveLength(2);
    });

    it('should dedupe duplicate URLs', () => {
      const mediaItems = [
        { url: 'https://mybucket.s3.amazonaws.com/image.jpg' },
        { url: 'https://mybucket.s3.amazonaws.com/image.jpg' },
      ];

      const result = categorizeMediaUrls(mediaItems);

      expect(result.s3Keys).toHaveLength(1);
    });

    it('should handle empty array', () => {
      const result = categorizeMediaUrls([]);

      expect(result.s3Keys).toHaveLength(0);
      expect(result.cloudinaryPublicIds).toHaveLength(0);
    });

    it('should skip unknown provider URLs', () => {
      const mediaItems = [
        { url: 'https://example.com/image.jpg' },
        { url: null },
      ];

      const result = categorizeMediaUrls(mediaItems);

      expect(result.s3Keys).toHaveLength(0);
      expect(result.cloudinaryPublicIds).toHaveLength(0);
    });
  });
});
```
  </action>
  <verify>
Test file exists with:
- Tests for parseMediaUrl (Cloudinary, S3, unknown)
- Tests for categorizeMediaUrls
- Edge cases (null, empty, duplicates)
  </verify>
  <done>
gdprDeletionService tests created covering URL parsing and categorization
  </done>
</task>

<task type="auto">
  <name>Task 2: Create gdprService tests</name>
  <files>tests/unit/gdprService.test.js</files>
  <action>
Create test file for gdprService functions.

```javascript
/**
 * Tests for GDPR Service
 *
 * Verifies data export and account deletion service functions.
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

// Mock supabase before importing service
vi.mock('../../src/supabase', () => ({
  supabase: {
    rpc: vi.fn(),
    from: vi.fn(() => ({
      select: vi.fn(() => ({
        eq: vi.fn(() => ({
          single: vi.fn(),
          order: vi.fn(() => ({
            limit: vi.fn(),
          })),
        })),
        order: vi.fn(() => ({
          limit: vi.fn(),
        })),
      })),
    })),
    auth: {
      getUser: vi.fn(),
    },
  },
}));

import { supabase } from '../../src/supabase';
import {
  requestDataExport,
  getLatestExportStatus,
  requestAccountDeletion,
  cancelAccountDeletion,
  getDeletionStatus,
  DELETION_REASONS,
} from '../../src/services/gdprService.js';

describe('gdprService', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('requestDataExport', () => {
    it('should call RPC with format parameter', async () => {
      supabase.rpc.mockResolvedValueOnce({ data: 'request-id-123', error: null });

      const result = await requestDataExport('json');

      expect(supabase.rpc).toHaveBeenCalledWith('request_data_export', { p_format: 'json' });
      expect(result.success).toBe(true);
      expect(result.requestId).toBe('request-id-123');
    });

    it('should default to json format', async () => {
      supabase.rpc.mockResolvedValueOnce({ data: 'request-id', error: null });

      await requestDataExport();

      expect(supabase.rpc).toHaveBeenCalledWith('request_data_export', { p_format: 'json' });
    });

    it('should return error on RPC failure', async () => {
      supabase.rpc.mockResolvedValueOnce({ data: null, error: { message: 'Already pending' } });

      const result = await requestDataExport();

      expect(result.success).toBe(false);
      expect(result.error).toBe('Already pending');
    });
  });

  describe('requestAccountDeletion', () => {
    it('should call RPC with reason and feedback', async () => {
      supabase.rpc
        .mockResolvedValueOnce({ data: 'deletion-id', error: null }) // request_account_deletion
        .mockResolvedValueOnce({ data: [{ days_remaining: 30 }], error: null }); // get_deletion_status

      const result = await requestAccountDeletion({
        reason: 'privacy_concerns',
        feedback: 'Closing account',
      });

      expect(supabase.rpc).toHaveBeenCalledWith('request_account_deletion', {
        p_reason: 'privacy_concerns',
        p_feedback: 'Closing account',
      });
      expect(result.success).toBe(true);
      expect(result.daysRemaining).toBe(30);
    });

    it('should handle null reason and feedback', async () => {
      supabase.rpc
        .mockResolvedValueOnce({ data: 'deletion-id', error: null })
        .mockResolvedValueOnce({ data: [], error: null });

      await requestAccountDeletion({});

      expect(supabase.rpc).toHaveBeenCalledWith('request_account_deletion', {
        p_reason: null,
        p_feedback: null,
      });
    });
  });

  describe('cancelAccountDeletion', () => {
    it('should call RPC and return success', async () => {
      supabase.rpc.mockResolvedValueOnce({ data: true, error: null });

      const result = await cancelAccountDeletion();

      expect(supabase.rpc).toHaveBeenCalledWith('cancel_account_deletion');
      expect(result.success).toBe(true);
    });

    it('should return error on failure', async () => {
      supabase.rpc.mockResolvedValueOnce({ data: null, error: { message: 'No request found' } });

      const result = await cancelAccountDeletion();

      expect(result.success).toBe(false);
      expect(result.error).toBe('No request found');
    });
  });

  describe('getDeletionStatus', () => {
    it('should return deletion status from RPC', async () => {
      const mockStatus = {
        id: 'status-id',
        status: 'scheduled',
        scheduled_deletion_at: '2026-02-23T00:00:00Z',
        days_remaining: 30,
      };
      supabase.rpc.mockResolvedValueOnce({ data: [mockStatus], error: null });

      const result = await getDeletionStatus();

      expect(supabase.rpc).toHaveBeenCalledWith('get_deletion_status');
      expect(result).toEqual(mockStatus);
    });

    it('should return null when no pending deletion', async () => {
      supabase.rpc.mockResolvedValueOnce({ data: [], error: null });

      const result = await getDeletionStatus();

      expect(result).toBeNull();
    });
  });

  describe('DELETION_REASONS', () => {
    it('should export array of reasons with id and label', () => {
      expect(Array.isArray(DELETION_REASONS)).toBe(true);
      expect(DELETION_REASONS.length).toBeGreaterThan(0);

      DELETION_REASONS.forEach((reason) => {
        expect(reason).toHaveProperty('id');
        expect(reason).toHaveProperty('label');
        expect(typeof reason.id).toBe('string');
        expect(typeof reason.label).toBe('string');
      });
    });

    it('should include privacy_concerns reason', () => {
      const privacyReason = DELETION_REASONS.find((r) => r.id === 'privacy_concerns');
      expect(privacyReason).toBeDefined();
      expect(privacyReason.label).toContain('Privacy');
    });
  });
});
```
  </action>
  <verify>
Test file exists with:
- Tests for requestDataExport
- Tests for requestAccountDeletion
- Tests for cancelAccountDeletion
- Tests for getDeletionStatus
- Tests for DELETION_REASONS constant
- Supabase mock setup
  </verify>
  <done>
gdprService tests created covering export and deletion service functions
  </done>
</task>

<task type="auto">
  <name>Task 3: Run tests and verify</name>
  <files>tests/unit/gdprService.test.js, tests/unit/gdprDeletionService.test.js</files>
  <action>
Run the GDPR test suite and verify all tests pass.

```bash
npm test -- tests/unit/gdprService.test.js tests/unit/gdprDeletionService.test.js
```

If tests fail:
1. Check imports are correct
2. Verify mock setup matches actual module structure
3. Fix any assertion issues
4. Re-run until all tests pass

Expected output: All tests pass with 0 failures.
  </action>
  <verify>
npm test output shows:
- gdprService tests: All passing
- gdprDeletionService tests: All passing
- No failures
  </verify>
  <done>
All GDPR unit tests pass, verifying service functions work correctly
  </done>
</task>

</tasks>

<verification>
- [ ] tests/unit/gdprDeletionService.test.js exists with URL parsing tests
- [ ] tests/unit/gdprService.test.js exists with service function tests
- [ ] parseMediaUrl tests cover Cloudinary, S3, and unknown URLs
- [ ] categorizeMediaUrls tests cover separation, deduplication, edge cases
- [ ] gdprService tests cover export and deletion functions
- [ ] Supabase properly mocked
- [ ] All tests pass with npm test
</verification>

<success_criteria>
- GDPR-01: Export request function tested
- GDPR-03: Deletion request and cancel functions tested
- URL parsing for S3 and Cloudinary verified
- Media categorization verified
- Error handling paths covered
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-gdpr-compliance/11-08-SUMMARY.md`
</output>
