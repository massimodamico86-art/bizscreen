---
phase: 01-testing-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/unit/player/Player.sync.test.jsx
autonomous: true

must_haves:
  truths:
    - "Content sync tests execute and pass with npm test"
    - "Test verifies player receives updated playlist from server"
    - "Test verifies player renders new content after sync"
    - "Test verifies content hash changes are detected"
  artifacts:
    - path: "tests/unit/player/Player.sync.test.jsx"
      provides: "Content sync flow characterization tests"
      min_lines: 120
  key_links:
    - from: "tests/unit/player/Player.sync.test.jsx"
      to: "src/Player.jsx"
      via: "import and render"
      pattern: "import.*Player"
---

<objective>
Create characterization tests for Player.jsx content synchronization flow.

Purpose: Verify the player correctly receives, processes, and displays updated content from the server. This ensures screens display current content when playlists are modified in the dashboard.

Output: Test file covering content sync with passing tests that verify correctness.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-testing-infrastructure/01-RESEARCH.md

# Existing test patterns
@tests/setup.js
@tests/utils/mocks.js

# Component under test - content sync logic
@src/Player.jsx (lines 2524-2596 - polling and content update logic)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create content sync flow tests</name>
  <files>tests/unit/player/Player.sync.test.jsx</files>
  <action>
Create characterization tests for Player.jsx content synchronization.

Test structure:
```
describe('Player.jsx - Content Sync Flow')
  describe('Initial content load')
    it('fetches content using getResolvedContent on mount')
    it('sets content state with server response')
    it('processes playlist items correctly')
    it('applies shuffle when playlist.shuffle is true')
    it('caches content for offline use after successful fetch')

  describe('Polling for updates')
    it('polls for content every 30 seconds')
    it('detects content changes via hash comparison')
    it('updates content when hash changes')
    it('resets playlist index to 0 on content update')
    it('sends heartbeat during poll cycle')

  describe('Content hash tracking')
    it('stores content hash in localStorage')
    it('compares stored hash with new content hash')
    it('updates hash after content change')

  describe('Realtime refresh events')
    it('refreshes content when scene_change event received')
    it('refreshes content when refresh_requested event received')
```

Key behaviors to verify (from src/Player.jsx lines 2524-2596):
1. Polling interval is 30 seconds (`setInterval(..., 30000)`)
2. Content change detection compares JSON.stringify of hash object
3. Hash includes: mode, source, playlistId, layoutId, campaignId
4. On hash change: setContent, setItems, setCurrentIndex(0)
5. Heartbeat sent via sendHeartbeat() each poll cycle

Mock setup:
- Mock `src/supabase` with configurable RPC responses
- Use vi.useFakeTimers() for polling tests
- vi.advanceTimersByTimeAsync(30000) to trigger poll
- Track state updates via rendered component

Test content payload format (from RPC):
```javascript
{
  mode: 'playlist',
  source: 'direct',
  playlist: { id: 'uuid', name: 'Test', shuffle: false, defaultDuration: 10 },
  items: [{ id: 'uuid', mediaType: 'image', url: '...', duration: 10 }],
  screen: { tenant_id: 'uuid' }
}
```

Verify the player:
1. Renders the content items
2. Transitions between items on timer
3. Updates when server content changes
  </action>
  <verify>
Run `npm test -- tests/unit/player/Player.sync.test.jsx` - all tests pass.
  </verify>
  <done>
Content sync tests exist and pass, verifying:
- Initial content load from server
- 30-second polling cycle
- Content change detection and update
- Heartbeat integration
  </done>
</task>

<task type="auto">
  <name>Task 2: Test playlist item rendering and transitions</name>
  <files>tests/unit/player/Player.sync.test.jsx</files>
  <action>
Add tests for content rendering and item transitions to the same test file.

Additional test cases:
```
describe('Player.jsx - Content Rendering')
  describe('Playlist item display')
    it('renders image items with correct src')
    it('renders video items with correct src')
    it('renders app widgets (weather, qr, etc)')

  describe('Item transitions')
    it('advances to next item after duration expires')
    it('loops back to first item after last item')
    it('re-shuffles playlist on cycle completion when shuffle enabled')
    it('respects item-specific duration over default')
```

Key behaviors (from src/Player.jsx):
1. Item duration: `currentItem.duration || content?.playlist?.defaultDuration || 10`
2. Timer in useEffect at line ~2645: `setTimeout(advanceToNext, duration * 1000)`
3. Shuffle on cycle: `if (next === 0 && content?.playlist?.shuffle) setItems(shuffleArray(items))`

Mock considerations:
- Use vi.useFakeTimers() for duration tests
- vi.advanceTimersByTime(duration * 1000) to trigger advance
- Query rendered content to verify what's displayed

Do NOT test visual styling - focus on behavioral correctness.
  </action>
  <verify>
Run `npm test -- tests/unit/player/Player.sync.test.jsx` - all tests pass including new rendering tests.
  </verify>
  <done>
Content sync tests cover full flow from fetch to render to transition.
  </done>
</task>

</tasks>

<verification>
```bash
# Run sync tests
npm test -- tests/unit/player/Player.sync.test.jsx

# Verify test count
npm test -- tests/unit/player/Player.sync.test.jsx --reporter=verbose 2>&1 | grep -c "PASS\|FAIL"
```

Expected: All content sync and rendering tests pass.
</verification>

<success_criteria>
1. `npm test` includes Player.sync.test.jsx and passes
2. Tests verify player receives updated playlist from server
3. Tests verify player renders updated content
4. Tests verify content hash change detection
5. Tests verify polling interval (30s) and heartbeat
</success_criteria>

<output>
After completion, create `.planning/phases/01-testing-infrastructure/01-02-SUMMARY.md`
</output>
