---
phase: 14-scheduling-core
plan: 03
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/components/schedules/WeekPreview.jsx
  - src/components/schedules/DraggableTimeBlock.jsx
  - src/components/schedules/index.js
  - src/services/scheduleService.js
autonomous: true

must_haves:
  truths:
    - "User can view 7-day visual preview with time slots as rows"
    - "User can drag entry blocks to reschedule to different day/time"
    - "User can resize entry blocks to change duration"
    - "User sees content thumbnail previews in grid cells"
  artifacts:
    - path: "src/components/schedules/WeekPreview.jsx"
      provides: "Interactive calendar grid with drag-drop"
      min_lines: 200
    - path: "src/components/schedules/DraggableTimeBlock.jsx"
      provides: "Draggable and resizable entry block"
      min_lines: 60
  key_links:
    - from: "src/components/schedules/WeekPreview.jsx"
      to: "@dnd-kit/core"
      via: "DndContext wrapper"
      pattern: "DndContext|useDraggable|useDroppable"
    - from: "src/components/schedules/WeekPreview.jsx"
      to: "scheduleService"
      via: "updateScheduleEntry on drop"
      pattern: "updateScheduleEntry"
---

<objective>
Create interactive drag-and-drop week preview visualization

Purpose: Enable users to visually manage their schedule with a 7-day calendar grid featuring drag-to-reschedule and resize-to-adjust-duration (SCHED-04).

Output: Enhanced WeekPreview with @dnd-kit integration, DraggableTimeBlock component, content thumbnails, and schedule mutation on drop
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-scheduling-core/14-CONTEXT.md
@.planning/phases/14-scheduling-core/14-RESEARCH.md
@.planning/phases/14-scheduling-core/14-01-PLAN.md
@src/components/schedules/WeekPreview.jsx
@src/components/schedules/index.js
@src/services/scheduleService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DraggableTimeBlock component</name>
  <files>
    src/components/schedules/DraggableTimeBlock.jsx
    src/components/schedules/index.js
  </files>
  <action>
Create a draggable and resizable time block component using @dnd-kit:

**DraggableTimeBlock.jsx:**

```jsx
import { useDraggable } from '@dnd-kit/core';
import { CSS } from '@dnd-kit/utilities';
import { PriorityBadge } from './PriorityBadge';
```

**Props:**
- entry: object (schedule entry with id, start_time, end_time, content_name, priority, thumbnail_url)
- slotHeight: number (pixels per time slot for positioning)
- onResize: (entryId, newDuration) => void
- disabled: boolean (disable drag when editing)

**Features:**

1. **Draggable with @dnd-kit:**
```jsx
const { attributes, listeners, setNodeRef, transform, isDragging } = useDraggable({
  id: entry.id,
  data: { entry }
});

const style = {
  transform: CSS.Translate.toString(transform),
  opacity: isDragging ? 0.5 : 1,
  zIndex: isDragging ? 1000 : 1,
};
```

2. **Visual block:**
- Background color based on event_type (content: blue, screen_off: gray)
- Show content thumbnail if available (small, aspect-fit)
- Show content name (truncated)
- Show time range (start_time - end_time)
- Show PriorityBadge (small size)
- Height calculated from duration

3. **Resize handle:**
Add a resize handle at the bottom:
```jsx
<div
  className="absolute bottom-0 left-0 right-0 h-2 cursor-ns-resize bg-blue-400/30 hover:bg-blue-400/50"
  onMouseDown={handleResizeStart}
/>
```

Resize implementation:
- Track mouse Y position during resize
- Calculate new end_time based on slot height and grid
- Call onResize callback with new duration
- Use state to track resizing mode

4. **Content thumbnail:**
If entry has thumbnail_url:
```jsx
{entry.thumbnail_url && (
  <img
    src={entry.thumbnail_url}
    alt=""
    className="w-8 h-8 object-cover rounded flex-shrink-0"
  />
)}
```

**Export from index.js:**
```javascript
export { DraggableTimeBlock } from './DraggableTimeBlock';
```
  </action>
  <verify>
Component exists with:
- useDraggable hook from @dnd-kit
- Resize handle element
- Thumbnail display
- PriorityBadge integration
  </verify>
  <done>
DraggableTimeBlock renders entry with drag capability, resize handle, thumbnail, and priority badge
  </done>
</task>

<task type="auto">
  <name>Task 2: Upgrade WeekPreview with drag-drop grid</name>
  <files>src/components/schedules/WeekPreview.jsx</files>
  <action>
Transform WeekPreview into interactive calendar grid per CONTEXT.md:
- "Calendar grid style: days as columns, time slots as rows"
- "Full drag and drop: drag to reschedule, resize to change duration"
- "Default scope: all devices combined view"

**1. Add @dnd-kit integration:**
```jsx
import { DndContext, useSensor, useSensors, PointerSensor, closestCenter } from '@dnd-kit/core';
import { useDroppable } from '@dnd-kit/core';
import { DraggableTimeBlock } from './DraggableTimeBlock';
```

**2. Configure sensors with activation constraint:**
```jsx
const sensors = useSensors(
  useSensor(PointerSensor, {
    activationConstraint: { distance: 8 }, // Prevent accidental drags
  })
);
```

**3. Create time slot grid structure:**
Per CONTEXT.md discretion, use 30-minute slots:
```jsx
const TIME_SLOTS = Array.from({ length: 48 }, (_, i) => {
  const hour = Math.floor(i / 2);
  const minute = (i % 2) * 30;
  return `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
});
```

**4. Layout: days as columns, time as rows:**
```jsx
<div className="grid" style={{ gridTemplateColumns: '60px repeat(7, 1fr)' }}>
  {/* Time labels column */}
  <div className="col-start-1">
    {TIME_SLOTS.map(time => (
      <div key={time} className="h-8 text-xs text-gray-400 pr-2 text-right">
        {formatTime(time)}
      </div>
    ))}
  </div>

  {/* Day columns with droppable slots */}
  {weekData.map((day, dayIndex) => (
    <div key={day.date} className="relative">
      {TIME_SLOTS.map(time => (
        <DroppableSlot
          key={`${day.date}-${time}`}
          id={`${day.date}-${time}`}
          date={day.date}
          time={time}
        />
      ))}
      {/* Positioned entries */}
      {day.entries.map(entry => (
        <DraggableTimeBlock
          key={entry.id}
          entry={entry}
          slotHeight={32} // 8 tailwind = 32px
          style={calculateEntryPosition(entry)}
          onResize={handleResize}
        />
      ))}
    </div>
  ))}
</div>
```

**5. DroppableSlot subcomponent:**
```jsx
function DroppableSlot({ id, date, time }) {
  const { setNodeRef, isOver } = useDroppable({
    id,
    data: { date, time }
  });

  return (
    <div
      ref={setNodeRef}
      className={`h-8 border-b border-gray-100 ${isOver ? 'bg-blue-50' : ''}`}
    />
  );
}
```

**6. Handle drag end - update schedule:**
```jsx
async function handleDragEnd(event) {
  const { active, over } = event;
  if (!over) return;

  const entry = active.data.current.entry;
  const { date, time } = over.data.current;

  // Calculate new start_time and date
  const newStartTime = time;
  const newDate = date;

  // Optimistic update
  setWeekData(prev => updateEntryInWeekData(prev, entry.id, { start_time: newStartTime, date: newDate }));

  // Persist to database
  try {
    await updateScheduleEntry(entry.id, {
      start_time: newStartTime,
      start_date: newDate,
      // Recalculate end_time based on original duration
    });
    // Refresh preview
    loadWeekPreview();
  } catch (err) {
    // Revert optimistic update
    loadWeekPreview();
    logger.error('Failed to update entry', { err });
  }
}
```

**7. Handle resize - update duration:**
```jsx
async function handleResize(entryId, newEndTime) {
  // Optimistic update
  setWeekData(prev => updateEntryEndTime(prev, entryId, newEndTime));

  // Persist
  try {
    await updateScheduleEntry(entryId, { end_time: newEndTime });
  } catch (err) {
    loadWeekPreview();
    logger.error('Failed to resize entry', { err });
  }
}
```

**8. Entry positioning:**
Calculate absolute position based on start_time and duration:
```jsx
function calculateEntryPosition(entry) {
  const startMinutes = timeToMinutes(entry.start_time);
  const endMinutes = timeToMinutes(entry.end_time);
  const duration = endMinutes - startMinutes;

  const slotHeight = 32; // pixels per 30-min slot
  const top = (startMinutes / 30) * slotHeight;
  const height = (duration / 30) * slotHeight;

  return {
    position: 'absolute',
    top: `${top}px`,
    height: `${height}px`,
    left: '4px',
    right: '4px',
  };
}
```

**9. Preserve existing features:**
- Week navigation (previous/next)
- Collapsible state
- Loading/error states
- Filler content display
- Today highlighting

**10. Add onEntryUpdate prop:**
```jsx
export function WeekPreview({
  scheduleId,
  onDayClick = null,
  onEntryUpdate = null, // NEW: callback when entry is moved/resized
  className = '',
  collapsible = true,
  defaultCollapsed = false
})
```
  </action>
  <verify>
1. WeekPreview renders grid with time slots as rows
2. Can drag entry block to different time slot
3. Drop updates the entry's start_time
4. Can resize entry by dragging bottom handle
5. Resize updates the entry's end_time
6. Entry thumbnails display when available
7. Week navigation still works
  </verify>
  <done>
WeekPreview renders interactive calendar grid with:
- Days as columns, 30-min time slots as rows
- Drag-to-reschedule functionality
- Resize-to-adjust-duration functionality
- Content thumbnails in entry blocks
- Persists changes to database
  </done>
</task>

<task type="auto">
  <name>Task 3: Add thumbnail support to schedule service</name>
  <files>src/services/scheduleService.js</files>
  <action>
Enhance getWeekPreview to include content thumbnails for visual display:

**1. Locate getWeekPreview function** (around line 790)

**2. Add thumbnail to returned entry data:**
The function already fetches content names. Extend to include thumbnail_url:

For scenes:
```javascript
const sceneNames = new Map();
if (contentIds.scene.size > 0) {
  const { data: scenes } = await supabase
    .from('scenes')
    .select('id, name, thumbnail_url')
    .in('id', Array.from(contentIds.scene));
  scenes?.forEach(s => sceneNames.set(s.id, { name: s.name, thumbnail: s.thumbnail_url }));
}
```

For playlists (get first item's thumbnail):
```javascript
const playlistInfo = new Map();
if (contentIds.playlist.size > 0) {
  const { data: playlists } = await supabase
    .from('playlists')
    .select(`
      id, name,
      playlist_items(
        media_assets(thumbnail_url)
      )
    `)
    .in('id', Array.from(contentIds.playlist))
    .order('position', { referencedTable: 'playlist_items', ascending: true })
    .limit(1, { referencedTable: 'playlist_items' });

  playlists?.forEach(p => {
    const thumbnail = p.playlist_items?.[0]?.media_assets?.thumbnail_url;
    playlistInfo.set(p.id, { name: p.name, thumbnail });
  });
}
```

**3. Include thumbnail in entry response:**
```javascript
entries: dayEntries.map(entry => ({
  id: entry.id,
  start_time: entry.start_time,
  end_time: entry.end_time,
  content_type: entry.content_type,
  content_id: entry.content_id,
  content_name: getContentName(entry),
  thumbnail_url: getContentThumbnail(entry), // NEW
  event_type: entry.event_type,
  priority: entry.priority
}))
```

**4. Helper for thumbnail lookup:**
```javascript
function getContentThumbnail(entry) {
  if (entry.content_type === 'scene') {
    return sceneNames.get(entry.content_id)?.thumbnail || null;
  }
  if (entry.content_type === 'playlist') {
    return playlistInfo.get(entry.content_id)?.thumbnail || null;
  }
  // layouts and media can also have thumbnails - add as needed
  return null;
}
```

This enables WeekPreview to show visual thumbnails for quick content identification.
  </action>
  <verify>
Call getWeekPreview and check response includes thumbnail_url for entries:
```javascript
const preview = await getWeekPreview(scheduleId, weekStart);
console.log(preview[0].entries[0].thumbnail_url);
```
  </verify>
  <done>
getWeekPreview returns thumbnail_url for schedule entries, enabling visual thumbnails in week grid
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
1. `npm run build` completes without errors
2. WeekPreview renders calendar grid (days as columns, time slots as rows)
3. Can drag entry block and drop on different time slot
4. Entry moves to new time slot after drop
5. Can resize entry by dragging bottom edge
6. Entry duration changes after resize
7. Content thumbnails appear in entry blocks
8. Changes persist to database (refresh confirms)
</verification>

<success_criteria>
- WeekPreview displays calendar grid layout with 30-min time slots
- DraggableTimeBlock component enables drag-to-move
- Resize handle enables duration adjustment
- Content thumbnails display in entry blocks
- Drag/resize changes persist to database
- No regressions to week navigation or existing functionality
- DST handling uses @date-fns/tz for time calculations
</success_criteria>

<output>
After completion, create `.planning/phases/14-scheduling-core/14-03-SUMMARY.md`
</output>
