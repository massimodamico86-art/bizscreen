---
phase: 02-xss-prevention
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/security/sanitize.js
  - src/services/securityService.js
  - src/pages/SecurityDashboardPage.jsx
  - src/App.jsx
autonomous: true

must_haves:
  truths:
    - "Sanitization events are logged to database"
    - "Security dashboard displays sanitization history"
    - "Users with repeated sanitization events are flagged in dashboard"
  artifacts:
    - path: "src/services/securityService.js"
      provides: "Security event logging and retrieval"
      exports: ["logSanitizationEvent", "getSanitizationEvents", "getFlaggedUsers"]
    - path: "src/pages/SecurityDashboardPage.jsx"
      provides: "Admin view of sanitization history"
      exports: ["default"]
  key_links:
    - from: "src/security/sanitize.js"
      to: "src/services/securityService.js"
      via: "DOMPurify hook calls logSanitizationEvent"
      pattern: "logSanitizationEvent"
    - from: "src/pages/SecurityDashboardPage.jsx"
      to: "src/services/securityService.js"
      via: "import and call getSanitizationEvents"
      pattern: "getSanitizationEvents"
---

<objective>
Create security logging infrastructure and admin dashboard for monitoring sanitization events.

Purpose: Per user decision, all sanitization events should be logged (not just suspicious ones), with a dedicated dashboard showing history and flagging users with repeated events. This enables security monitoring without blocking legitimate content.

Output: Security service for logging, DOMPurify hooks for capture, and admin dashboard page.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-xss-prevention/02-CONTEXT.md
@.planning/phases/02-xss-prevention/02-RESEARCH.md
@.planning/phases/02-xss-prevention/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create security service for sanitization event logging</name>
  <files>src/services/securityService.js</files>
  <action>
    Create `src/services/securityService.js` with the following exports:

    **logSanitizationEvent({ userId, removedElements, context, timestamp }):**
    - Inserts record into `sanitization_events` table via Supabase
    - Store summary only (element types/counts), NOT actual malicious content per research recommendation
    - Fields: id (uuid), user_id, removed_summary (jsonb), context (string - where sanitization occurred), created_at
    - If Supabase call fails, log error but don't throw (silent failure for logging)

    **getSanitizationEvents({ limit = 50, offset = 0 }):**
    - Fetches recent sanitization events with user info
    - Returns array of events with user email for display
    - Order by created_at DESC

    **getFlaggedUsers({ threshold = 5 }):**
    - Returns users with more than `threshold` sanitization events
    - Groups by user_id, counts events, filters by count > threshold
    - Returns user email and event count

    **Database migration needed:**
    Create migration file `supabase/migrations/115_sanitization_events.sql`:
    ```sql
    CREATE TABLE sanitization_events (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
      removed_summary JSONB NOT NULL DEFAULT '{}',
      context TEXT,
      created_at TIMESTAMPTZ DEFAULT NOW()
    );

    CREATE INDEX idx_sanitization_events_user_id ON sanitization_events(user_id);
    CREATE INDEX idx_sanitization_events_created_at ON sanitization_events(created_at DESC);

    -- RLS: Only admins can read sanitization events
    ALTER TABLE sanitization_events ENABLE ROW LEVEL SECURITY;

    CREATE POLICY "Admins can view sanitization events"
      ON sanitization_events FOR SELECT
      USING (
        EXISTS (
          SELECT 1 FROM user_roles
          WHERE user_roles.user_id = auth.uid()
          AND user_roles.role IN ('admin', 'super_admin')
        )
      );

    CREATE POLICY "System can insert sanitization events"
      ON sanitization_events FOR INSERT
      WITH CHECK (true);
    ```
  </action>
  <verify>
    - `ls src/services/securityService.js` shows file exists
    - File exports logSanitizationEvent, getSanitizationEvents, getFlaggedUsers
    - Migration file exists at supabase/migrations/115_sanitization_events.sql
  </verify>
  <done>
    - securityService.js created with all three functions
    - Database migration created for sanitization_events table
    - RLS policies restrict read to admins
  </done>
</task>

<task type="auto">
  <name>Task 2: Add DOMPurify hooks to capture sanitization events</name>
  <files>src/security/sanitize.js</files>
  <action>
    Update `src/security/sanitize.js` to add DOMPurify hooks:

    1. Import logSanitizationEvent from '../services/securityService'

    2. Add initialization function `initSanitizationLogging(getCurrentUser)`:
       - Accepts a function that returns current user (to avoid auth coupling)
       - Adds DOMPurify.addHook('afterSanitizeElements') to track removed elements
       - Uses DOMPurify.removed array to get what was stripped
       - Calls logSanitizationEvent with summary data
       - Export this function

    3. The hook should:
       - Only log if something was actually removed (DOMPurify.removed.length > 0)
       - Create summary: { scripts: N, handlers: N, iframes: N, other: N }
       - NOT store the actual malicious content (per research recommendation)
       - Include context parameter for where sanitization occurred (optional)

    **Example hook implementation:**
    ```javascript
    export function initSanitizationLogging(getCurrentUser) {
      DOMPurify.addHook('afterSanitizeElements', (currentNode, data, config) => {
        if (DOMPurify.removed && DOMPurify.removed.length > 0) {
          const summary = DOMPurify.removed.reduce((acc, item) => {
            if (item.element?.tagName === 'SCRIPT') acc.scripts++;
            else if (item.attribute?.name?.startsWith('on')) acc.handlers++;
            else if (item.element?.tagName === 'IFRAME') acc.iframes++;
            else acc.other++;
            return acc;
          }, { scripts: 0, handlers: 0, iframes: 0, other: 0 });

          const user = getCurrentUser?.();
          logSanitizationEvent({
            userId: user?.id,
            removedSummary: summary,
            context: config?.CONTEXT || 'unknown',
            timestamp: new Date().toISOString()
          });
        }
      });
    }
    ```

    4. Update sanitizeHTML to accept optional context parameter:
       ```javascript
       export function sanitizeHTML(html, customConfig = {}) {
         const config = { ...SANITIZE_CONFIG, ...customConfig };
         return DOMPurify.sanitize(html, config);
       }
       ```

    5. Export initSanitizationLogging from index.js
  </action>
  <verify>
    - `grep "addHook" src/security/sanitize.js` shows hook registration
    - `grep "initSanitizationLogging" src/security/index.js` shows export
    - `grep "logSanitizationEvent" src/security/sanitize.js` shows service usage
  </verify>
  <done>
    - DOMPurify hook captures sanitization events
    - Summary data (not malicious content) is logged
    - initSanitizationLogging function exported
  </done>
</task>

<task type="auto">
  <name>Task 3: Create security dashboard page</name>
  <files>src/pages/SecurityDashboardPage.jsx, src/App.jsx</files>
  <action>
    **Create src/pages/SecurityDashboardPage.jsx:**

    1. Import from design system: PageLayout, PageHeader, PageContent, Card, Table components
    2. Import { getSanitizationEvents, getFlaggedUsers } from '../services/securityService'
    3. Use standard page pattern from other pages in src/pages/

    **Page structure:**
    - Header: "Security Dashboard" with description "Monitor sanitization events and flagged users"
    - Two sections:
      a. "Flagged Users" - users with 5+ sanitization events (threshold)
         - Table: Email, Event Count, Last Event
         - If no flagged users: "No users flagged" message
      b. "Recent Sanitization Events" - last 50 events
         - Table: Time, User, Context, Summary (scripts/handlers removed)
         - Pagination if needed (optional for MVP)

    **State:**
    - events: array of sanitization events
    - flaggedUsers: array of users with high event counts
    - loading: boolean
    - error: string | null

    **useEffect on mount:**
    - Call getSanitizationEvents and getFlaggedUsers
    - Set state with results
    - Handle errors gracefully

    **Add route in App.jsx:**
    - Find where routes are defined (likely react-router or custom routing)
    - Add route for '/security' or '/admin/security' pointing to SecurityDashboardPage
    - Route should only be accessible to admin users (check existing admin route pattern)
  </action>
  <verify>
    - `ls src/pages/SecurityDashboardPage.jsx` shows file exists
    - `grep "SecurityDashboard" src/App.jsx` shows route added
    - File imports from securityService
  </verify>
  <done>
    - SecurityDashboardPage.jsx created with flagged users and events display
    - Route added to App.jsx for admin access
    - Dashboard imports and uses securityService functions
  </done>
</task>

</tasks>

<verification>
1. Migration file exists: `ls supabase/migrations/115_sanitization_events.sql`
2. Service file exists with exports: `grep -E "export.*(logSanitizationEvent|getSanitizationEvents|getFlaggedUsers)" src/services/securityService.js`
3. DOMPurify hooks configured: `grep "addHook" src/security/sanitize.js`
4. Dashboard page exists: `ls src/pages/SecurityDashboardPage.jsx`
5. Route configured: `grep -i "security" src/App.jsx`
</verification>

<success_criteria>
- Sanitization events table created via migration
- Security service logs events and retrieves history
- DOMPurify hooks capture sanitization without storing malicious content
- Security dashboard displays events and flags repeat offenders
- Dashboard accessible only to admin users
</success_criteria>

<output>
After completion, create `.planning/phases/02-xss-prevention/02-04-SUMMARY.md`
</output>
