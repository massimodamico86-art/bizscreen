---
phase: 15-scheduling-campaigns
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/125_daypart_presets.sql
  - src/services/daypartService.js
  - src/components/schedules/DaypartPicker.jsx
  - src/components/schedules/index.js
  - src/pages/ScheduleEditorPage.jsx
autonomous: true

must_haves:
  truths:
    - "User can apply dayparting preset to schedule entry"
    - "User can create custom daypart presets"
    - "Meal-based presets available: Breakfast, Lunch, Dinner"
    - "Period-based presets available: Morning, Afternoon, Evening, Night"
    - "Applying preset sets entry's start_time, end_time, days_of_week"
  artifacts:
    - path: "supabase/migrations/125_daypart_presets.sql"
      provides: "daypart_presets table with system defaults"
      contains: "CREATE TABLE.*daypart_presets"
    - path: "src/services/daypartService.js"
      provides: "Daypart CRUD and application"
      exports: ["getDaypartPresets", "applyDaypartToEntry", "createDaypartPreset"]
      min_lines: 80
    - path: "src/components/schedules/DaypartPicker.jsx"
      provides: "Preset selection with create custom option"
      min_lines: 100
  key_links:
    - from: "src/pages/ScheduleEditorPage.jsx"
      to: "src/components/schedules/DaypartPicker.jsx"
      via: "import and render"
      pattern: "DaypartPicker"
    - from: "src/services/daypartService.js"
      to: "supabase.from('schedule_entries')"
      via: "time field updates"
      pattern: "start_time.*end_time"
---

<objective>
Implement customizable dayparting presets for quick time block scheduling

Purpose: Users want to quickly apply common time blocks (Breakfast 6-10am, Lunch 11am-2pm, etc.) to schedule entries rather than manually entering times. Presets are customizable and can be tenant-specific.

Output: Daypart presets table with seed data, daypartService, DaypartPicker component integrated in schedule editor
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-scheduling-campaigns/15-RESEARCH.md
@.planning/phases/15-scheduling-campaigns/15-CONTEXT.md

# Schedule editor integration
@src/pages/ScheduleEditorPage.jsx
@src/services/scheduleService.js

# Existing component patterns
@src/components/schedules/FillerContentPicker.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create daypart_presets table with defaults</name>
  <files>supabase/migrations/125_daypart_presets.sql</files>
  <action>
Create migration 125_daypart_presets.sql:

1. Create daypart_presets table:
   ```sql
   CREATE TABLE daypart_presets (
     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
     tenant_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
     name TEXT NOT NULL,
     preset_type TEXT NOT NULL CHECK (preset_type IN ('meal', 'period', 'custom')),
     start_time TIME NOT NULL,
     end_time TIME NOT NULL,
     days_of_week INT[] DEFAULT '{0,1,2,3,4,5,6}',
     is_system BOOLEAN DEFAULT false,
     created_at TIMESTAMPTZ DEFAULT now(),
     updated_at TIMESTAMPTZ DEFAULT now()
   );
   ```

2. Add indexes:
   - idx_daypart_presets_tenant on (tenant_id)
   - idx_daypart_presets_system on (tenant_id) WHERE is_system = true

3. Add updated_at trigger (use existing update_updated_at_column function)

4. Insert system presets (tenant_id = NULL, is_system = true):
   Meal-based:
   - Breakfast: 06:00 - 10:00
   - Lunch: 11:00 - 14:00
   - Dinner: 17:00 - 21:00

   Period-based (6hr blocks):
   - Morning: 06:00 - 12:00
   - Afternoon: 12:00 - 18:00
   - Evening: 18:00 - 00:00
   - Night: 00:00 - 06:00

5. RLS policies:
   - SELECT: User can see system presets (tenant_id IS NULL) AND their own presets
   - INSERT: User can create presets for their tenant only
   - UPDATE: User can update their own non-system presets
   - DELETE: User can delete their own non-system presets

Comments explaining preset_type and is_system flag usage.
  </action>
  <verify>
Run migration:
```bash
npx supabase db push --local
```
Verify seed data:
```bash
npx supabase db dump --local --data-only | grep "daypart_presets"
```
  </verify>
  <done>daypart_presets table exists with 7 system presets seeded</done>
</task>

<task type="auto">
  <name>Task 2: Create daypartService</name>
  <files>src/services/daypartService.js</files>
  <action>
Create daypartService.js with structured logging:

1. DEFAULT_DAYPARTS constant (for reference/fallback):
   ```javascript
   export const DEFAULT_DAYPARTS = {
     meal: [
       { name: 'Breakfast', start_time: '06:00', end_time: '10:00' },
       { name: 'Lunch', start_time: '11:00', end_time: '14:00' },
       { name: 'Dinner', start_time: '17:00', end_time: '21:00' }
     ],
     period: [
       { name: 'Morning', start_time: '06:00', end_time: '12:00' },
       { name: 'Afternoon', start_time: '12:00', end_time: '18:00' },
       { name: 'Evening', start_time: '18:00', end_time: '00:00' },
       { name: 'Night', start_time: '00:00', end_time: '06:00' }
     ]
   };
   ```

2. getDaypartPresets():
   - Query daypart_presets WHERE tenant_id IS NULL OR tenant_id = user.id
   - Order by preset_type, start_time
   - Return array with system presets first, then custom

3. createDaypartPreset({ name, startTime, endTime, daysOfWeek, presetType = 'custom' }):
   - Insert into daypart_presets with tenant_id = user.id, is_system = false
   - Return created preset
   - Log: 'Created daypart preset', { name, presetType }

4. updateDaypartPreset(presetId, updates):
   - Update only if tenant_id = user.id AND is_system = false
   - Updates: name, start_time, end_time, days_of_week
   - Return updated preset
   - Log: 'Updated daypart preset', { presetId }

5. deleteDaypartPreset(presetId):
   - Delete only if tenant_id = user.id AND is_system = false
   - Log: 'Deleted daypart preset', { presetId }

6. applyDaypartToEntry(entryId, presetId):
   - Fetch preset's start_time, end_time, days_of_week
   - Update schedule_entries SET those fields WHERE id = entryId
   - Return updated entry
   - Log: 'Applied daypart to entry', { entryId, presetId }

7. bulkApplyDaypart(entryIds, presetId):
   - Same as above but UPDATE ... WHERE id IN (entryIds)
   - Return count of updated entries
   - Log: 'Bulk applied daypart', { entryCount: entryIds.length, presetId }

Use createScopedLogger('DaypartService').
  </action>
  <verify>
Lint check:
```bash
npm run lint -- --fix src/services/daypartService.js
```
Import test.
  </verify>
  <done>daypartService exports all daypart operations</done>
</task>

<task type="auto">
  <name>Task 3: Create DaypartPicker and integrate</name>
  <files>
    src/components/schedules/DaypartPicker.jsx
    src/components/schedules/index.js
    src/pages/ScheduleEditorPage.jsx
  </files>
  <action>
1. Create DaypartPicker.jsx:
   - Props: onApply (callback with preset), disabled, showCreateOption
   - State: presets (from getDaypartPresets), loading, creating, newPreset form

   UI Structure:
   - Dropdown/Select with grouped options:
     - Group: "Meal-based" - Breakfast, Lunch, Dinner
     - Group: "Period-based" - Morning, Afternoon, Evening, Night
     - Group: "Custom" - User's custom presets (if any)
     - Divider
     - "Create Custom Preset..." option

   - Each option shows: Name + time range (e.g., "Breakfast (6:00 AM - 10:00 AM)")

   - Create Custom dialog (modal or inline form):
     - Name input
     - Start time picker (use existing time input pattern)
     - End time picker
     - Days of week checkboxes (optional, default all)
     - Save button

   - On select: call onApply(preset) with full preset object

   Follow existing picker patterns (FillerContentPicker has similar load-on-mount + select pattern).

2. Update index.js barrel:
   - Add DaypartPicker export

3. Integrate in ScheduleEditorPage.jsx:
   - Import DaypartPicker
   - Add "Quick Apply" section in entry edit form (above or beside time inputs)
   - When preset applied via onApply:
     - Update entry's start_time, end_time, days_of_week with preset values
     - Show toast confirmation: "Applied {preset.name} time block"
   - This is a helper that fills time fields, not a saved association

Note: DaypartPicker is a "quick fill" tool, not a persistent link. Applying a preset copies values into the entry's time fields.
  </action>
  <verify>
Build passes:
```bash
npm run build
```
Visual: Open schedule editor, entry form shows DaypartPicker with preset options.
  </verify>
  <done>DaypartPicker renders presets, selecting one fills entry time fields</done>
</task>

</tasks>

<verification>
After all tasks:
1. Database: `SELECT * FROM daypart_presets WHERE is_system = true;` returns 7 rows
2. Service: daypartService functions import correctly
3. UI: DaypartPicker shows grouped presets in schedule editor
4. Integration test:
   - Open schedule entry form
   - Select "Breakfast" from DaypartPicker
   - Verify start_time = 06:00, end_time = 10:00 in form fields
   - Save entry, verify times persisted
</verification>

<success_criteria>
- daypart_presets table exists with 7 system presets
- daypartService can CRUD presets and apply to entries
- DaypartPicker shows meal and period presets grouped
- Selecting preset fills entry's time fields immediately
- User can create custom preset from picker
- Custom presets appear in picker after creation
</success_criteria>

<output>
After completion, create `.planning/phases/15-scheduling-campaigns/15-03-SUMMARY.md`
</output>
