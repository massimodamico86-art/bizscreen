---
phase: 15-scheduling-campaigns
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/124_emergency_override.sql
  - src/services/emergencyService.js
  - src/contexts/EmergencyContext.jsx
  - src/components/campaigns/EmergencyBanner.jsx
  - src/components/campaigns/index.js
  - src/components/layout/AdminLayout.jsx
  - src/components/layout/Header.jsx
autonomous: true

must_haves:
  truths:
    - "User can push emergency content that overrides all schedules"
    - "Emergency banner visible on all admin pages"
    - "User can stop emergency with single click"
    - "Emergency has optional duration for auto-restore"
    - "All tenant devices refresh when emergency starts/stops"
  artifacts:
    - path: "supabase/migrations/124_emergency_override.sql"
      provides: "Emergency state columns on profiles"
      contains: "emergency_content_id"
    - path: "src/services/emergencyService.js"
      provides: "Emergency push/stop operations"
      exports: ["pushEmergencyContent", "stopEmergency", "getTenantEmergencyState"]
      min_lines: 80
    - path: "src/contexts/EmergencyContext.jsx"
      provides: "Global emergency state"
      exports: ["EmergencyProvider", "useEmergency"]
      min_lines: 60
    - path: "src/components/campaigns/EmergencyBanner.jsx"
      provides: "Persistent red banner"
      min_lines: 40
  key_links:
    - from: "src/components/layout/AdminLayout.jsx"
      to: "src/contexts/EmergencyContext.jsx"
      via: "EmergencyProvider wrapper"
      pattern: "EmergencyProvider"
    - from: "src/services/emergencyService.js"
      to: "supabase.from('tv_devices')"
      via: "needs_refresh flag"
      pattern: "needs_refresh.*true"
---

<objective>
Implement tenant-wide emergency content override system

Purpose: Users need to immediately broadcast emergency content (e.g., evacuation notice, urgent announcement) to all their screens, overriding all schedules. The emergency state persists until manually stopped or duration expires.

Output: Emergency service, context provider, persistent banner, and database schema for emergency state
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-scheduling-campaigns/15-RESEARCH.md
@.planning/phases/15-scheduling-campaigns/15-CONTEXT.md

# Existing realtime patterns
@src/services/realtimeService.js

# Layout integration points
@src/components/layout/AdminLayout.jsx
@src/components/layout/Header.jsx

# Logging pattern
@src/services/loggingService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add emergency state schema</name>
  <files>supabase/migrations/124_emergency_override.sql</files>
  <action>
Create migration 124_emergency_override.sql:

1. Add emergency columns to profiles table:
   - emergency_content_id UUID (content being shown)
   - emergency_content_type TEXT (playlist/scene/media)
   - emergency_started_at TIMESTAMPTZ (when emergency started)
   - emergency_duration_minutes INTEGER (NULL = indefinite)

2. Add constraint for valid content types:
   - CHECK (emergency_content_type IS NULL OR emergency_content_type IN ('playlist', 'scene', 'media'))

3. Add index for emergency lookups:
   - idx_profiles_emergency on (id) WHERE emergency_content_id IS NOT NULL

Comments:
- Emergency content overrides all schedules/campaigns
- Duration NULL means "until manually stopped"
- Store started_at (not expires_at) to calculate expiry on each check
  </action>
  <verify>
Run migration:
```bash
npx supabase db push --local
```
Verify columns:
```bash
npx supabase db dump --local --data-only | grep "emergency_content"
```
  </verify>
  <done>profiles table has emergency_* columns</done>
</task>

<task type="auto">
  <name>Task 2: Create emergencyService</name>
  <files>src/services/emergencyService.js</files>
  <action>
Create emergencyService.js with structured logging:

1. EMERGENCY_DURATIONS constant:
   - { value: 15, label: '15 minutes' }
   - { value: 60, label: '1 hour' }
   - { value: 240, label: '4 hours' }
   - { value: null, label: 'Until manually stopped' }

2. getTenantEmergencyState():
   - Get current user's tenant_id
   - Query profiles for emergency_* columns
   - Return { contentId, contentType, startedAt, durationMinutes, isActive }
   - isActive: contentId is not null AND (duration is null OR not expired)

3. pushEmergencyContent(contentType, contentId, durationMinutes = null):
   - Update profiles SET emergency_* columns
   - Set needs_refresh = true on ALL tenant tv_devices
   - Log: 'Pushing emergency content', { contentType, contentId, durationMinutes }
   - Return void (throws on error)

4. stopEmergency():
   - Update profiles SET emergency_* = NULL
   - Set needs_refresh = true on ALL tenant tv_devices
   - Log: 'Stopping emergency'

5. subscribeToEmergencyState(tenantId, onStateChange):
   - Use Supabase Realtime channel 'emergency:{tenantId}'
   - Subscribe to profiles table changes WHERE id = tenantId
   - Call onStateChange with new emergency state on UPDATE
   - Return unsubscribe function

6. isEmergencyExpired(startedAt, durationMinutes):
   - Helper function
   - Returns false if durationMinutes is null
   - Returns true if current time > startedAt + durationMinutes

Use createScopedLogger('EmergencyService').
  </action>
  <verify>
Lint check:
```bash
npm run lint -- --fix src/services/emergencyService.js
```
Import test in node console or test file.
  </verify>
  <done>emergencyService exports all emergency operations with Realtime subscription</done>
</task>

<task type="auto">
  <name>Task 3: Create EmergencyContext and EmergencyBanner</name>
  <files>
    src/contexts/EmergencyContext.jsx
    src/components/campaigns/EmergencyBanner.jsx
    src/components/campaigns/index.js
    src/components/layout/AdminLayout.jsx
  </files>
  <action>
1. Create EmergencyContext.jsx:
   - EmergencyProvider component wrapping children
   - On mount: fetch getTenantEmergencyState()
   - Subscribe to emergency state changes via subscribeToEmergencyState
   - Context value: { isActive, contentId, contentType, contentName, startedAt, durationMinutes, stopEmergency, stopping }
   - stopEmergency wrapped with loading state
   - Fetch content name from appropriate table based on contentType
   - Cleanup subscription on unmount
   - useEmergency() hook for consuming context

2. Create EmergencyBanner.jsx:
   - Use useEmergency() hook
   - Return null if !isActive
   - Render fixed top banner:
     - bg-red-600 text-white
     - AlertTriangle icon (animated pulse)
     - "EMERGENCY ACTIVE" text
     - Content name
     - Time remaining (or "Until manually stopped")
     - Stop button (with loading state)
   - Use lucide-react for icons (AlertTriangle, XCircle)
   - Position: fixed top-0 left-0 right-0 z-50

3. Create/update index.js barrel:
   - mkdir src/components/campaigns if needed
   - Export EmergencyBanner

4. Update AdminLayout.jsx:
   - Import EmergencyProvider from contexts
   - Import EmergencyBanner from components/campaigns
   - Wrap layout in EmergencyProvider
   - Add EmergencyBanner at top of layout (before other content)
   - Add padding-top when emergency active to prevent content overlap

Follow existing context patterns (e.g., AuthContext, ThemeContext if they exist).
  </action>
  <verify>
Build passes:
```bash
npm run build
```
Visual: Log in to admin, verify no banner (no emergency). Context loads without error.
  </verify>
  <done>EmergencyProvider wraps admin layout, EmergencyBanner conditionally renders</done>
</task>

</tasks>

<verification>
After all tasks:
1. Database: `SELECT emergency_content_id FROM profiles LIMIT 1;` returns column
2. Service: emergencyService functions import correctly
3. Context: useEmergency() hook returns isActive: false initially
4. UI: AdminLayout wrapped in EmergencyProvider, no banner visible (no active emergency)
5. Integration test (manual):
   - Directly update profiles table: `UPDATE profiles SET emergency_content_id = 'some-uuid', emergency_content_type = 'scene', emergency_started_at = now();`
   - Verify banner appears on admin pages
   - Click Stop, verify banner disappears
</verification>

<success_criteria>
- profiles table has emergency_* columns
- emergencyService can push/stop emergency and subscribe to changes
- EmergencyContext provides global emergency state
- EmergencyBanner appears when emergency active
- All admin pages show banner (via AdminLayout)
- Stop button clears emergency and refreshes all devices
</success_criteria>

<output>
After completion, create `.planning/phases/15-scheduling-campaigns/15-02-SUMMARY.md`
</output>
