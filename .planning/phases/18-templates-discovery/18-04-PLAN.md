---
phase: 18-templates-discovery
plan: 04
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - src/components/templates/TemplateCustomizationWizard.jsx
  - src/components/templates/index.js
  - src/pages/TemplateMarketplacePage.jsx
  - src/services/marketplaceService.js
autonomous: true

must_haves:
  truths:
    - "Wizard opens after Quick Apply when template has customizable fields"
    - "User can upload/select logo in wizard"
    - "User can pick primary color in wizard"
    - "User can edit text placeholders in wizard"
    - "Live preview updates as user makes changes"
    - "Changes are applied to the created scene"
  artifacts:
    - path: "src/components/templates/TemplateCustomizationWizard.jsx"
      provides: "Side-by-side wizard with form and live preview"
      min_lines: 150
    - path: "src/services/marketplaceService.js"
      provides: "applyCustomizationToScene function"
      exports: ["applyCustomizationToScene"]
  key_links:
    - from: "src/pages/TemplateMarketplacePage.jsx"
      to: "TemplateCustomizationWizard"
      via: "wizardState conditional render"
      pattern: "wizardState.*open"
    - from: "src/components/templates/TemplateCustomizationWizard.jsx"
      to: "applyCustomizationToScene"
      via: "onComplete handler"
      pattern: "applyCustomizationToScene"
---

<objective>
Template customization wizard with side-by-side form and live preview.

Purpose: Allow users to personalize templates immediately after Quick Apply with logo, colors, and text changes before entering the full editor.
Output: Full-screen wizard component, customization service function, integration with marketplace flow
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-templates-discovery/18-CONTEXT.md
@.planning/phases/18-templates-discovery/18-RESEARCH.md
@.planning/phases/18-templates-discovery/18-01-SUMMARY.md
@src/components/templates/TemplatePreviewPanel.jsx
@src/components/templates/TemplateCustomizeModal.jsx
@src/pages/TemplateMarketplacePage.jsx
@src/services/marketplaceService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TemplateCustomizationWizard component</name>
  <files>src/components/templates/TemplateCustomizationWizard.jsx, src/components/templates/index.js</files>
  <action>
Create a full-screen wizard with side-by-side layout: form on left, live preview on right.

**Per CONTEXT.md:**
- Single-screen form (not multi-step)
- Triggers after Quick Apply (scene created first)
- Side-by-side layout with live preview

```jsx
/**
 * Template Customization Wizard
 *
 * Full-screen wizard for customizing a newly created scene from a template.
 * Shows form fields on left, live preview on right.
 * Supports: logo upload, primary color, text replacements.
 */

import { useState, useEffect, useCallback } from 'react';
import PropTypes from 'prop-types';
import { motion } from 'framer-motion';
import { X, Upload, Loader2, Image as ImageIcon } from 'lucide-react';

export function TemplateCustomizationWizard({
  template,
  sceneId,
  onComplete,
  onSkip,
}) {
  // Customization state
  const [customization, setCustomization] = useState({
    logo: null,
    logoPreview: null,
    primaryColor: '#3B82F6',
    texts: {},
  });
  const [applying, setApplying] = useState(false);

  // Extract customizable fields from template metadata
  const customizableFields = template?.metadata?.customizable_fields || {};
  const textFields = customizableFields.texts || [];
  const hasLogo = customizableFields.logo !== false;
  const hasColor = customizableFields.color !== false;

  // Initialize text fields with template defaults
  useEffect(() => {
    if (textFields.length > 0) {
      const initialTexts = {};
      textFields.forEach((field) => {
        initialTexts[field.key] = field.default || '';
      });
      setCustomization((prev) => ({ ...prev, texts: initialTexts }));
    }
  }, [template]);

  // Handle logo file selection
  const handleLogoChange = (e) => {
    const file = e.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        setCustomization((prev) => ({
          ...prev,
          logo: file,
          logoPreview: reader.result,
        }));
      };
      reader.readAsDataURL(file);
    }
  };

  // Handle color change
  const handleColorChange = (e) => {
    setCustomization((prev) => ({
      ...prev,
      primaryColor: e.target.value,
    }));
  };

  // Handle text change
  const handleTextChange = (key, value) => {
    setCustomization((prev) => ({
      ...prev,
      texts: { ...prev.texts, [key]: value },
    }));
  };

  // Handle apply
  const handleApply = async () => {
    setApplying(true);
    try {
      await onComplete(customization);
    } catch (error) {
      console.error('Failed to apply customization:', error);
      setApplying(false);
    }
  };

  // Handle skip
  const handleSkip = () => {
    onSkip();
  };

  // Handle escape key
  useEffect(() => {
    const handleEscape = (e) => {
      if (e.key === 'Escape' && !applying) {
        handleSkip();
      }
    };
    window.addEventListener('keydown', handleEscape);
    return () => window.removeEventListener('keydown', handleEscape);
  }, [applying]);

  return (
    <motion.div
      className="fixed inset-0 z-50 flex bg-white"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
    >
      {/* Left Panel: Form */}
      <div className="w-[400px] flex-shrink-0 border-r bg-white flex flex-col">
        {/* Header */}
        <div className="p-4 border-b flex items-center justify-between">
          <div>
            <h2 className="text-lg font-semibold text-gray-900">Customize Template</h2>
            <p className="text-sm text-gray-500">{template?.name}</p>
          </div>
          <button
            onClick={handleSkip}
            disabled={applying}
            className="p-2 text-gray-400 hover:text-gray-600 rounded-lg hover:bg-gray-100"
            aria-label="Skip customization"
          >
            <X size={20} />
          </button>
        </div>

        {/* Form Content */}
        <div className="flex-1 overflow-y-auto p-6 space-y-6">
          {/* Logo Upload */}
          {hasLogo && (
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Logo
              </label>
              <div className="border-2 border-dashed border-gray-300 rounded-lg p-4 text-center hover:border-gray-400 transition-colors">
                {customization.logoPreview ? (
                  <div className="space-y-2">
                    <img
                      src={customization.logoPreview}
                      alt="Logo preview"
                      className="max-h-20 mx-auto object-contain"
                    />
                    <button
                      onClick={() => setCustomization((prev) => ({ ...prev, logo: null, logoPreview: null }))}
                      className="text-sm text-red-600 hover:text-red-800"
                    >
                      Remove
                    </button>
                  </div>
                ) : (
                  <label className="cursor-pointer">
                    <input
                      type="file"
                      accept="image/*"
                      onChange={handleLogoChange}
                      className="hidden"
                    />
                    <div className="space-y-2">
                      <Upload size={24} className="mx-auto text-gray-400" />
                      <p className="text-sm text-gray-500">
                        Click to upload logo
                      </p>
                      <p className="text-xs text-gray-400">
                        PNG, JPG up to 2MB
                      </p>
                    </div>
                  </label>
                )}
              </div>
            </div>
          )}

          {/* Primary Color */}
          {hasColor && (
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Primary Color
              </label>
              <div className="flex items-center gap-3">
                <input
                  type="color"
                  value={customization.primaryColor}
                  onChange={handleColorChange}
                  className="w-12 h-12 rounded-lg border border-gray-300 cursor-pointer"
                />
                <input
                  type="text"
                  value={customization.primaryColor}
                  onChange={handleColorChange}
                  className="flex-1 px-3 py-2 border border-gray-300 rounded-lg text-sm font-mono"
                  placeholder="#3B82F6"
                />
              </div>
            </div>
          )}

          {/* Text Replacements */}
          {textFields.length > 0 && (
            <div className="space-y-4">
              <h3 className="text-sm font-medium text-gray-700">Text Content</h3>
              {textFields.map((field) => (
                <div key={field.key}>
                  <label className="block text-sm text-gray-600 mb-1">
                    {field.label}
                  </label>
                  {field.multiline ? (
                    <textarea
                      value={customization.texts[field.key] || ''}
                      onChange={(e) => handleTextChange(field.key, e.target.value)}
                      placeholder={field.placeholder}
                      rows={3}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm resize-none"
                    />
                  ) : (
                    <input
                      type="text"
                      value={customization.texts[field.key] || ''}
                      onChange={(e) => handleTextChange(field.key, e.target.value)}
                      placeholder={field.placeholder}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm"
                    />
                  )}
                </div>
              ))}
            </div>
          )}

          {/* No customizations available */}
          {!hasLogo && !hasColor && textFields.length === 0 && (
            <div className="text-center py-8 text-gray-500">
              <ImageIcon size={48} className="mx-auto mb-3 text-gray-300" />
              <p>This template doesn't have customizable fields.</p>
              <p className="text-sm mt-1">You can edit it in the scene editor.</p>
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="p-4 border-t bg-gray-50 flex gap-3">
          <button
            onClick={handleSkip}
            disabled={applying}
            className="flex-1 py-2.5 px-4 border border-gray-300 text-gray-700 font-medium rounded-lg hover:bg-gray-100 disabled:opacity-50"
          >
            Skip
          </button>
          <button
            onClick={handleApply}
            disabled={applying}
            className="flex-1 py-2.5 px-4 bg-blue-600 text-white font-medium rounded-lg hover:bg-blue-700 disabled:opacity-50 flex items-center justify-center gap-2"
          >
            {applying ? (
              <>
                <Loader2 size={16} className="animate-spin" />
                Applying...
              </>
            ) : (
              'Apply & Edit'
            )}
          </button>
        </div>
      </div>

      {/* Right Panel: Preview */}
      <div className="flex-1 bg-gray-100 flex items-center justify-center p-8">
        <div className="w-full max-w-4xl aspect-video bg-white rounded-xl shadow-lg overflow-hidden">
          {/* Preview placeholder - in real implementation would render scene with customizations */}
          <div className="w-full h-full flex flex-col items-center justify-center text-gray-400">
            {template?.thumbnail_url || template?.preview_url ? (
              <img
                src={template.preview_url || template.thumbnail_url}
                alt="Template preview"
                className="w-full h-full object-cover"
                style={{
                  filter: `hue-rotate(${getHueRotation(customization.primaryColor)}deg)`,
                }}
              />
            ) : (
              <>
                <ImageIcon size={64} className="mb-4" />
                <p>Preview will update as you customize</p>
              </>
            )}
          </div>
        </div>
        <p className="absolute bottom-4 text-sm text-gray-500">
          Preview may not reflect all changes until you open the editor
        </p>
      </div>
    </motion.div>
  );
}

// Helper to approximate hue rotation from hex color (simplified)
function getHueRotation(hexColor) {
  // Simple approximation - in production would use proper color math
  const r = parseInt(hexColor.slice(1, 3), 16);
  const g = parseInt(hexColor.slice(3, 5), 16);
  const b = parseInt(hexColor.slice(5, 7), 16);
  // Very rough hue estimation
  return Math.round((r - b) / 2);
}

TemplateCustomizationWizard.propTypes = {
  template: PropTypes.shape({
    id: PropTypes.string.isRequired,
    name: PropTypes.string.isRequired,
    thumbnail_url: PropTypes.string,
    preview_url: PropTypes.string,
    metadata: PropTypes.object,
  }).isRequired,
  sceneId: PropTypes.string.isRequired,
  onComplete: PropTypes.func.isRequired,
  onSkip: PropTypes.func.isRequired,
};

export default TemplateCustomizationWizard;
```

**Update index.js:**
```jsx
export { TemplateCustomizationWizard } from './TemplateCustomizationWizard';
```
  </action>
  <verify>
Component renders with form fields
Logo upload works
Color picker works
Text fields work
Skip button works
  </verify>
  <done>
TemplateCustomizationWizard component created with side-by-side layout
  </done>
</task>

<task type="auto">
  <name>Task 2: Add customization service function</name>
  <files>src/services/marketplaceService.js</files>
  <action>
Add function to apply customizations to a scene:

```javascript
// ============================================================================
// CUSTOMIZATION
// ============================================================================

/**
 * Apply customizations to a scene
 * Updates scene slides with logo, colors, and text replacements.
 *
 * @param {string} sceneId - Scene UUID
 * @param {Object} customization - Customization data
 * @param {File|null} customization.logo - Logo file to upload
 * @param {string} customization.primaryColor - Hex color
 * @param {Object} customization.texts - Key-value text replacements
 * @returns {Promise<void>}
 */
export async function applyCustomizationToScene(sceneId, customization) {
  const { logo, primaryColor, texts } = customization;

  // 1. Upload logo if provided
  let logoUrl = null;
  if (logo) {
    const fileName = `scenes/${sceneId}/logo.${logo.name.split('.').pop()}`;
    const { error: uploadError } = await supabase.storage
      .from('scene-assets')
      .upload(fileName, logo, { upsert: true });

    if (uploadError) {
      logger.error({ error: uploadError, sceneId }, 'Failed to upload logo');
      throw uploadError;
    }

    const { data: urlData } = supabase.storage
      .from('scene-assets')
      .getPublicUrl(fileName);

    logoUrl = urlData.publicUrl;
  }

  // 2. Fetch scene slides
  const { data: slides, error: fetchError } = await supabase
    .from('scene_slides')
    .select('id, design_json')
    .eq('scene_id', sceneId);

  if (fetchError) throw fetchError;
  if (!slides || slides.length === 0) return;

  // 3. Apply customizations to each slide's design_json
  for (const slide of slides) {
    let designJson = slide.design_json || {};
    let modified = false;

    // Apply color replacement (if design has color placeholders)
    if (primaryColor && designJson) {
      designJson = applyColorToDesign(designJson, primaryColor);
      modified = true;
    }

    // Apply text replacements
    if (texts && Object.keys(texts).length > 0) {
      designJson = applyTextsToDesign(designJson, texts);
      modified = true;
    }

    // Apply logo URL
    if (logoUrl) {
      designJson = applyLogoToDesign(designJson, logoUrl);
      modified = true;
    }

    // Update slide if modified
    if (modified) {
      const { error: updateError } = await supabase
        .from('scene_slides')
        .update({ design_json: designJson })
        .eq('id', slide.id);

      if (updateError) {
        logger.error({ error: updateError, slideId: slide.id }, 'Failed to update slide');
      }
    }
  }

  logger.info({ sceneId, hasLogo: !!logoUrl, hasColor: !!primaryColor, textCount: Object.keys(texts || {}).length }, 'Applied customizations to scene');
}

/**
 * Apply primary color to design JSON
 * Looks for elements with customizable color flags
 */
function applyColorToDesign(designJson, color) {
  // Deep clone to avoid mutation
  const design = JSON.parse(JSON.stringify(designJson));

  // Recursively find elements with customizable_color flag
  function walkElements(elements) {
    if (!Array.isArray(elements)) return;
    for (const el of elements) {
      if (el.customizable_color || el.type === 'primary_color') {
        el.fill = color;
        el.backgroundColor = color;
      }
      if (el.children) walkElements(el.children);
      if (el.objects) walkElements(el.objects);
    }
  }

  if (design.objects) walkElements(design.objects);
  if (design.elements) walkElements(design.elements);

  return design;
}

/**
 * Apply text replacements to design JSON
 * Looks for elements with text_key property
 */
function applyTextsToDesign(designJson, texts) {
  const design = JSON.parse(JSON.stringify(designJson));

  function walkElements(elements) {
    if (!Array.isArray(elements)) return;
    for (const el of elements) {
      if (el.text_key && texts[el.text_key] !== undefined) {
        el.text = texts[el.text_key];
      }
      if (el.children) walkElements(el.children);
      if (el.objects) walkElements(el.objects);
    }
  }

  if (design.objects) walkElements(design.objects);
  if (design.elements) walkElements(design.elements);

  return design;
}

/**
 * Apply logo URL to design JSON
 * Looks for elements with logo placeholder
 */
function applyLogoToDesign(designJson, logoUrl) {
  const design = JSON.parse(JSON.stringify(designJson));

  function walkElements(elements) {
    if (!Array.isArray(elements)) return;
    for (const el of elements) {
      if (el.is_logo || el.type === 'logo_placeholder') {
        el.src = logoUrl;
        el.type = 'image';
      }
      if (el.children) walkElements(el.children);
      if (el.objects) walkElements(el.objects);
    }
  }

  if (design.objects) walkElements(design.objects);
  if (design.elements) walkElements(design.elements);

  return design;
}
```

Note: The actual design_json structure may vary based on your scene editor format. The functions above are templates that walk through the design looking for customizable elements. Adjust the property names (customizable_color, text_key, is_logo) based on how templates mark their customizable elements.
  </action>
  <verify>
Function exports correctly
No TypeScript/ESLint errors
  </verify>
  <done>
applyCustomizationToScene function created with logo upload, color, and text application
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire wizard into marketplace page Quick Apply flow</name>
  <files>src/pages/TemplateMarketplacePage.jsx</files>
  <action>
**Update TemplateMarketplacePage.jsx:**

1. Import wizard component and service:
```jsx
import {
  // ... existing
  TemplateCustomizationWizard,
} from '../components/templates';

import {
  // ... existing
  applyCustomizationToScene,
} from '../services/marketplaceService';
```

2. Add wizard state:
```jsx
const [wizardState, setWizardState] = useState({
  open: false,
  template: null,
  sceneId: null,
});
```

3. Update handleQuickApply to check for customizable fields:
```jsx
const handleQuickApply = async (template) => {
  setApplyingId(template.id);
  try {
    const sceneName = `${template.name} - ${format(new Date(), 'MMM d, yyyy')}`;
    const sceneId = await installTemplateAsScene(template.id, sceneName);

    // Check if template has customizable fields
    const hasCustomization = template.metadata?.customizable_fields &&
      (template.metadata.customizable_fields.logo !== false ||
       template.metadata.customizable_fields.color !== false ||
       (template.metadata.customizable_fields.texts?.length > 0));

    if (hasCustomization) {
      // Open wizard
      setWizardState({
        open: true,
        template,
        sceneId,
      });
      setApplyingId(null);
    } else {
      // No customization, go directly to editor
      navigate(`/scene-editor/${sceneId}`);
    }
  } catch (error) {
    console.error('Failed to apply template:', error);
    setApplyingId(null);
  }
};
```

4. Add wizard handlers:
```jsx
const handleWizardComplete = async (customization) => {
  try {
    await applyCustomizationToScene(wizardState.sceneId, customization);
    setWizardState({ open: false, template: null, sceneId: null });
    navigate(`/scene-editor/${wizardState.sceneId}`);
  } catch (error) {
    console.error('Failed to apply customization:', error);
    throw error; // Let wizard handle error state
  }
};

const handleWizardSkip = () => {
  setWizardState({ open: false, template: null, sceneId: null });
  navigate(`/scene-editor/${wizardState.sceneId}`);
};
```

5. Render wizard (at end of component, after AnimatePresence for preview panel):
```jsx
{/* Customization Wizard */}
<AnimatePresence>
  {wizardState.open && wizardState.template && wizardState.sceneId && (
    <TemplateCustomizationWizard
      template={wizardState.template}
      sceneId={wizardState.sceneId}
      onComplete={handleWizardComplete}
      onSkip={handleWizardSkip}
    />
  )}
</AnimatePresence>
```

6. Also update preview panel apply flow to support wizard:
Update handleApplySuccess to check for customization:
```jsx
const handleApplySuccess = async (sceneId) => {
  setSelectedTemplate(null);

  // Check if template has customizable fields
  const hasCustomization = selectedTemplate?.metadata?.customizable_fields &&
    (selectedTemplate.metadata.customizable_fields.logo !== false ||
     selectedTemplate.metadata.customizable_fields.color !== false ||
     (selectedTemplate.metadata.customizable_fields.texts?.length > 0));

  if (hasCustomization) {
    setWizardState({
      open: true,
      template: selectedTemplate,
      sceneId,
    });
  } else {
    navigate(`/scene-editor/${sceneId}`);
  }
};
```
  </action>
  <verify>
Quick Apply on template with customizable_fields opens wizard
Wizard Skip navigates to editor
Wizard Apply applies customizations then navigates
Templates without customizable_fields go directly to editor
  </verify>
  <done>
Wizard integrated into Quick Apply flow, opens for templates with customizable fields
  </done>
</task>

</tasks>

<verification>
1. Quick Apply on template with metadata.customizable_fields opens wizard
2. Wizard shows logo upload when enabled
3. Wizard shows color picker when enabled
4. Wizard shows text fields from template definition
5. Skip button closes wizard and navigates to editor
6. Apply button calls customization service and navigates
7. Preview shows template image (color tint as visual hint)
8. Templates without customizable_fields skip wizard
</verification>

<success_criteria>
- [ ] TemplateCustomizationWizard component created
- [ ] Side-by-side layout (form left, preview right)
- [ ] Logo upload with preview works
- [ ] Color picker with hex input works
- [ ] Text fields render from template metadata
- [ ] Skip closes wizard and navigates to editor
- [ ] Apply calls applyCustomizationToScene service
- [ ] applyCustomizationToScene updates scene slides
- [ ] Quick Apply checks for customizable_fields
- [ ] Wizard opens only for templates with customization
</success_criteria>

<output>
After completion, create `.planning/phases/18-templates-discovery/18-04-SUMMARY.md`
</output>
