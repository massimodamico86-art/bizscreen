---
phase: 26-analytics-completion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/138_campaign_rotation_weights.sql
autonomous: true

must_haves:
  truths:
    - "Campaign content selection uses weighted random algorithm when multiple items exist"
    - "Single-item campaigns return that item directly without random overhead"
    - "Null/zero weight items are treated as weight=1 (equal distribution)"
    - "get_resolved_player_content integrates campaign resolution in priority chain"
  artifacts:
    - path: "supabase/migrations/138_campaign_rotation_weights.sql"
      provides: "Weighted campaign content selection and integration"
      contains: "select_weighted_campaign_content"
  key_links:
    - from: "get_resolved_player_content"
      to: "select_weighted_campaign_content"
      via: "Function call for campaign content resolution"
      pattern: "select_weighted_campaign_content"
---

<objective>
Add weighted random selection for campaign content rotation in player content resolution.

Purpose: Campaigns with multiple content items should rotate based on configured weights, not just return the first item by position. This enables promotional content to play with configurable frequency.

Output: Migration file with weighted selection helper and updated content resolution RPC.
</objective>

<execution_context>
@/Users/massimodamico/.claude/get-shit-done/workflows/execute-plan.md
@/Users/massimodamico/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-analytics-completion/26-RESEARCH.md

Key existing code:
- supabase/migrations/135_group_language_inheritance.sql - Current get_resolved_player_content (no campaign support)
- supabase/migrations/026_screen_groups_and_campaigns.sql - get_active_campaign_for_screen helper
- supabase/migrations/128_rotation_frequency_limits.sql - campaign_contents.rotation_mode and weight columns
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create weighted campaign content selection migration</name>
  <files>supabase/migrations/138_campaign_rotation_weights.sql</files>
  <action>
Create migration file with:

1. **select_weighted_campaign_content function** - PostgreSQL function that:
   - Takes campaign_id as input
   - Returns content_type and content_id
   - Single-item optimization: if COUNT(*) = 1, return directly without random
   - For multiple items: implement weighted random selection using cumulative weights
   - Handle null/zero weights with COALESCE(weight, 1) and filter WHERE > 0
   - Use position for ordering in cumulative sum

   Algorithm (from RESEARCH.md):
   ```sql
   WITH weighted AS (
     SELECT
       cc.content_type,
       cc.content_id,
       COALESCE(cc.weight, 1) as weight,
       SUM(COALESCE(cc.weight, 1)) OVER (ORDER BY cc.position) as cumulative,
       SUM(COALESCE(cc.weight, 1)) OVER () as total
     FROM campaign_contents cc
     WHERE cc.campaign_id = p_campaign_id
       AND COALESCE(cc.weight, 1) > 0
   ),
   rnd AS (
     SELECT random() * (SELECT MAX(total) FROM weighted) as point
   )
   SELECT w.content_type, w.content_id
   FROM weighted w, rnd r
   WHERE w.cumulative > r.point
   ORDER BY w.cumulative
   LIMIT 1;
   ```

2. **Update get_active_campaign_for_screen** - Modify to call select_weighted_campaign_content instead of ordering by position/weight with LIMIT 1.

3. **Update get_resolved_player_content** - Add campaign resolution step between Emergency and Device Scene checks:
   - Call get_active_campaign_for_screen
   - If campaign found, resolve content based on content_type (playlist, layout, media)
   - Return with source='campaign' and campaign metadata
   - Priority: Emergency (999) > Campaign > Device Scene > Group Scene > Schedule > etc.

Migration structure:
```sql
-- ============================================
-- Migration 138: Campaign Rotation Weights
-- ============================================
-- Implements weighted random selection for campaign content rotation.
-- Integrates campaign resolution into get_resolved_player_content.
--
-- ANLY-02: Campaign rotation weights enforced in player content resolution

-- 1. Weighted content selection helper
CREATE OR REPLACE FUNCTION public.select_weighted_campaign_content(...)

-- 2. Update get_active_campaign_for_screen to use weighted selection
CREATE OR REPLACE FUNCTION public.get_active_campaign_for_screen(...)

-- 3. Update get_resolved_player_content to include campaign resolution
CREATE OR REPLACE FUNCTION public.get_resolved_player_content(...)
```

Key points:
- Preserve ALL existing functionality from migration 135 (emergency, scenes, schedules, language resolution)
- Insert campaign check AFTER emergency but BEFORE device scene check
- Campaign content_type can be 'playlist', 'layout', or 'media'
- Use the existing pattern from migration 026 for resolving playlist/layout content
- Function should be STABLE (not VOLATILE) for select_weighted_campaign_content since it reads data
- Actually use VOLATILE for weighted selection since random() is involved
  </action>
  <verify>
Run: `cd /Users/massimodamico/bizscreen && supabase db reset --local` to apply migration.
Verify with SQL:
```sql
-- Test weighted selection helper
SELECT * FROM public.select_weighted_campaign_content('test-campaign-uuid');

-- Test that get_resolved_player_content returns campaign content
SELECT * FROM public.get_resolved_player_content('test-screen-uuid');
```
  </verify>
  <done>
Migration file exists at supabase/migrations/138_campaign_rotation_weights.sql.
Functions select_weighted_campaign_content, get_active_campaign_for_screen, and get_resolved_player_content are created/updated.
Campaign content uses weighted random selection when multiple items exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify template usage tracking already works</name>
  <files>src/components/onboarding/StarterPackOnboarding.jsx, src/services/marketplaceService.js</files>
  <action>
Verify that ANLY-01 is already satisfied by tracing the call path:

1. Open StarterPackOnboarding.jsx and confirm it calls installTemplateAsScene
2. Open marketplaceService.js and confirm installTemplateAsScene calls recordMarketplaceUsage
3. Confirm recordMarketplaceUsage inserts into marketplace_template_history

This is a verification task - no code changes needed unless the above is not true.
If verification fails, add recordMarketplaceUsage call to StarterPackOnboarding.

Expected finding: ANLY-01 is already implemented. The call chain is:
StarterPackOnboarding.handleApplySelected → installTemplateAsScene → recordMarketplaceUsage → marketplace_template_history

Document verification result in SUMMARY.md.
  </action>
  <verify>
Read the source files and trace the call path.
grep -n "installTemplateAsScene" src/components/onboarding/StarterPackOnboarding.jsx
grep -n "recordMarketplaceUsage" src/services/marketplaceService.js
  </verify>
  <done>
Verified that StarterPackOnboarding → installTemplateAsScene → recordMarketplaceUsage chain exists.
ANLY-01 template usage tracking is confirmed working with no changes needed.
  </done>
</task>

</tasks>

<verification>
1. Migration 138 applies without errors via supabase db reset
2. select_weighted_campaign_content returns content from campaigns with multiple items
3. get_resolved_player_content returns campaign content when an active campaign targets the screen
4. Template usage is recorded when starter pack templates are applied (existing functionality verified)
</verification>

<success_criteria>
- [ ] Migration 138_campaign_rotation_weights.sql created and valid SQL
- [ ] select_weighted_campaign_content implements weighted random selection
- [ ] get_active_campaign_for_screen uses weighted selection instead of LIMIT 1
- [ ] get_resolved_player_content includes campaign resolution in priority chain
- [ ] ANLY-01 verified as already working (no changes needed)
- [ ] ANLY-02 implemented via weighted campaign content selection
</success_criteria>

<output>
After completion, create `.planning/phases/26-analytics-completion/26-01-SUMMARY.md`
</output>
