---
phase: 07-player-refactoring
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - src/Player.jsx
  - src/player/hooks/useKioskMode.js
  - src/player/hooks/usePlayerPlayback.js
  - src/player/hooks/index.js
  - tests/unit/player/Player.hooks.test.jsx
autonomous: true

must_haves:
  truths:
    - "Player.jsx is under 500 lines"
    - "Kiosk mode exit with password works correctly"
    - "Playback timing and video handling work correctly"
    - "All 167+ Player tests pass"
    - "Offline playback works identically to before"
  artifacts:
    - path: "src/Player.jsx"
      provides: "Router and page components"
      max_lines: 500
    - path: "src/player/hooks/useKioskMode.js"
      provides: "Kiosk state, fullscreen, password exit"
      min_lines: 60
      exports: ["useKioskMode"]
    - path: "src/player/hooks/usePlayerPlayback.js"
      provides: "Slide timing, video control, analytics"
      min_lines: 80
      exports: ["usePlayerPlayback"]
    - path: "tests/unit/player/Player.hooks.test.jsx"
      provides: "Hook unit tests"
      min_lines: 100
  key_links:
    - from: "src/Player.jsx ViewPage"
      to: "src/player/hooks/useKioskMode.js"
      via: "hook call"
      pattern: "useKioskMode\\("
    - from: "src/player/hooks/usePlayerPlayback.js"
      to: "src/services/playerAnalyticsService.js"
      via: "analytics tracking"
      pattern: "analytics\\."
---

<objective>
Complete Player.jsx refactoring and add hook tests

Purpose: Extract remaining hooks (useKioskMode, usePlayerPlayback), reduce Player.jsx to under 500 lines, and add unit tests for extracted hooks. This completes Phase 7 requirements.

Output: Player.jsx under 500 lines, 5 total hooks tested, all success criteria met
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-player-refactoring/07-RESEARCH.md
@.planning/phases/07-player-refactoring/07-02-SUMMARY.md
@src/Player.jsx
@src/player/hooks/index.js
@tests/unit/player/Player.test.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract useKioskMode and usePlayerPlayback hooks</name>
  <files>
    src/player/hooks/useKioskMode.js
    src/player/hooks/usePlayerPlayback.js
    src/player/hooks/index.js
  </files>
  <action>
**Create useKioskMode.js** extracting kiosk logic from ViewPage:

```javascript
import { useState, useEffect, useCallback } from 'react';
import { useLogger } from '../../hooks/useLogger.js';
import { isFullscreen, enterFullscreen, exitFullscreen, validateKioskPassword } from '../../services/playerService';

const STORAGE_KEYS = {
  kioskMode: 'player_kiosk_mode',
  kioskPassword: 'player_kiosk_password',
};

export function useKioskMode() {
  const logger = useLogger('useKioskMode');
  const [kioskMode, setKioskMode] = useState(() =>
    localStorage.getItem(STORAGE_KEYS.kioskMode) === 'true'
  );
  const [showKioskExit, setShowKioskExit] = useState(false);
  const [kioskPasswordInput, setKioskPasswordInput] = useState('');
  const [kioskPasswordError, setKioskPasswordError] = useState('');

  // Keyboard handler (Escape to show exit dialog)
  useEffect(() => {
    if (!kioskMode) return;

    const handleKeyDown = (e) => {
      if (e.key === 'Escape') {
        e.preventDefault();
        setShowKioskExit(true);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [kioskMode]);

  // Re-enter fullscreen if exited in kiosk mode
  useEffect(() => {
    if (!kioskMode) return;

    const handleFullscreenChange = () => {
      if (!isFullscreen() && kioskMode) {
        setTimeout(() => {
          enterFullscreen().catch(err =>
            logger.warn('Failed to enter fullscreen', { error: err })
          );
        }, 100);
      }
    };

    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);

    return () => {
      document.removeEventListener('fullscreenchange', handleFullscreenChange);
      document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
    };
  }, [kioskMode, logger]);

  // Handle kiosk exit
  const handleKioskExit = useCallback(async () => {
    const savedPassword = localStorage.getItem(STORAGE_KEYS.kioskPassword);

    if (savedPassword) {
      // Try offline validation first, then online
      const isValid = await validateKioskPassword(kioskPasswordInput, savedPassword);
      if (!isValid) {
        setKioskPasswordError('Incorrect password');
        return;
      }
    }

    // Exit kiosk mode
    setKioskMode(false);
    setShowKioskExit(false);
    setKioskPasswordInput('');
    setKioskPasswordError('');
    localStorage.setItem(STORAGE_KEYS.kioskMode, 'false');
    exitFullscreen().catch(err =>
      logger.warn('Failed to exit fullscreen', { error: err })
    );
  }, [kioskPasswordInput, logger]);

  const cancelKioskExit = useCallback(() => {
    setShowKioskExit(false);
    setKioskPasswordInput('');
    setKioskPasswordError('');
  }, []);

  return {
    kioskMode,
    showKioskExit,
    kioskPasswordInput,
    kioskPasswordError,
    setKioskPasswordInput,
    handleKioskExit,
    cancelKioskExit,
  };
}
```

**Create usePlayerPlayback.js** extracting playback timing logic:

```javascript
import { useEffect, useRef, useCallback } from 'react';
import { useLogger } from '../../hooks/useLogger.js';
import * as analytics from '../../services/playerAnalyticsService';

export function usePlayerPlayback(
  items,
  currentIndex,
  content,
  advanceToNext
) {
  const logger = useLogger('usePlayerPlayback');
  const timerRef = useRef(null);
  const videoRef = useRef(null);
  const lastActivityRef = useRef(Date.now());
  const lastVideoTimeRef = useRef(0);

  // Track playback analytics
  useEffect(() => {
    const mode = content?.mode || content?.type;
    if (mode !== 'playlist' || items.length === 0) return;
    const currentItem = items[currentIndex];
    if (!currentItem) return;

    const screenId = localStorage.getItem('player_screen_id');
    if (!screenId) return;

    analytics.startPlaybackEvent({
      screenId,
      tenantId: content.screen?.tenant_id,
      locationId: content.screen?.location_id || null,
      playlistId: content.playlist?.id || null,
      layoutId: null,
      zoneId: null,
      mediaId: currentItem.mediaType !== 'app' ? currentItem.id : null,
      appId: currentItem.mediaType === 'app' ? currentItem.id : null,
      campaignId: content.campaign?.id || null,
      itemType: currentItem.mediaType === 'app' ? 'app' : 'media',
      itemName: currentItem.name,
    });

    return () => {
      // Note: advanceToNext handles ending, but this catches unmount
    };
  }, [currentIndex, items, content]);

  // Timer for image/document duration
  useEffect(() => {
    if (items.length === 0) return;

    const currentItem = items[currentIndex];
    if (!currentItem) return;

    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }

    // For videos, let onEnded handler advance
    if (currentItem.mediaType === 'video') {
      return;
    }

    const duration = (currentItem.duration || content?.playlist?.defaultDuration || 10) * 1000;
    timerRef.current = setTimeout(advanceToNext, duration);

    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
  }, [currentIndex, items, content?.playlist?.defaultDuration, advanceToNext]);

  // Video end handler
  const handleVideoEnd = useCallback(() => {
    advanceToNext();
  }, [advanceToNext]);

  return {
    videoRef,
    timerRef,
    lastActivityRef,
    lastVideoTimeRef,
    handleVideoEnd,
  };
}
```

**Update index.js:**
```javascript
export { usePlayerContent } from './usePlayerContent.js';
export { usePlayerHeartbeat } from './usePlayerHeartbeat.js';
export { usePlayerCommands } from './usePlayerCommands.js';
export { useKioskMode } from './useKioskMode.js';
export { usePlayerPlayback } from './usePlayerPlayback.js';
```
  </action>
  <verify>
```bash
# Verify new hooks exist
ls src/player/hooks/
# Verify exports
grep "export function" src/player/hooks/*.js | wc -l
# Should show 5 hooks
```
  </verify>
  <done>useKioskMode and usePlayerPlayback hooks extracted, index.js exports all 5 hooks</done>
</task>

<task type="auto">
  <name>Task 2: Final ViewPage consolidation</name>
  <files>
    src/Player.jsx
  </files>
  <action>
**Update ViewPage to use all 5 hooks:**

1. Update imports:
```javascript
import {
  usePlayerContent,
  usePlayerHeartbeat,
  usePlayerCommands,
  useKioskMode,
  usePlayerPlayback,
} from './player/hooks';
```

2. Simplify ViewPage to only contain:
- Hook calls
- Refs (contentContainerRef, loadContentRef)
- Simple derived state (hasContent, contentMode)
- handleDisconnect function
- Render logic (loading, error, content display)

```javascript
function ViewPage() {
  const navigate = useNavigate();
  const logger = useLogger('ViewPage');
  const screenId = localStorage.getItem(STORAGE_KEYS.screenId);

  // Refs
  const contentContainerRef = useRef(null);
  const loadContentRef = useRef(null);

  // Content management
  const {
    content,
    items,
    currentIndex,
    loading,
    error,
    connectionStatus,
    isOfflineMode,
    loadContent,
    advanceToNext,
    setContent,
    setItems,
    setCurrentIndex,
  } = usePlayerContent(screenId, navigate);

  // Update ref for heartbeat
  useEffect(() => {
    loadContentRef.current = loadContent;
  }, [loadContent]);

  // Heartbeat
  usePlayerHeartbeat(screenId, loadContentRef, contentContainerRef);

  // Commands
  const { handleCommand } = usePlayerCommands(
    screenId, setContent, setItems, setCurrentIndex, navigate, logger
  );

  // Kiosk mode
  const {
    kioskMode,
    showKioskExit,
    kioskPasswordInput,
    kioskPasswordError,
    setKioskPasswordInput,
    handleKioskExit,
    cancelKioskExit,
  } = useKioskMode();

  // Playback timing
  const {
    videoRef,
    handleVideoEnd,
    lastActivityRef,
  } = usePlayerPlayback(items, currentIndex, content, advanceToNext);

  // Stuck detection (keep inline - uses local refs)
  // ... stuck detection effect

  // Disconnect handler
  const handleDisconnect = () => {
    localStorage.removeItem(STORAGE_KEYS.screenId);
    localStorage.removeItem(STORAGE_KEYS.playlistId);
    localStorage.removeItem(STORAGE_KEYS.contentHash);
    navigate('/player', { replace: true });
  };

  // ... render logic (unchanged)
}
```

3. **Remove from ViewPage** (now in hooks):
- All kiosk state and effects
- Timer/playback state and effects
- Analytics tracking effects

4. **Keep in ViewPage** (cannot be easily extracted):
- Stuck detection effect (uses videoRef, lastActivityRef, advanceToNext)
- All rendering JSX
- handleDisconnect (simple, view-specific)

**Target: ViewPage should be ~300-400 lines of mostly rendering logic**
  </action>
  <verify>
```bash
# Check ViewPage line count (should be under 500)
grep -n "function ViewPage" src/Player.jsx
# Count lines in ViewPage (approximate)

# Check total Player.jsx line count
wc -l src/Player.jsx

# Run tests
npm test -- --run
```
  </verify>
  <done>ViewPage uses all 5 hooks, Player.jsx is under target line count</done>
</task>

<task type="auto">
  <name>Task 3: Add hook unit tests and verify phase completion</name>
  <files>
    tests/unit/player/Player.hooks.test.jsx
  </files>
  <action>
**Create hook unit tests** to verify extracted hooks work correctly:

```javascript
/**
 * Player Hooks Unit Tests
 *
 * Tests for the extracted custom hooks from Player.jsx
 * Phase 7: Player Refactoring
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { renderHook, act, waitFor } from '@testing-library/react';

// Mock services before imports
vi.mock('../../../src/services/playerService', () => ({
  updateDeviceStatus: vi.fn().mockResolvedValue({ needs_screenshot_update: false }),
  cacheContent: vi.fn().mockResolvedValue(undefined),
  getCachedContent: vi.fn().mockResolvedValue(null),
  clearCache: vi.fn().mockResolvedValue(undefined),
  calculateBackoff: vi.fn().mockReturnValue(1000),
  isFullscreen: vi.fn().mockReturnValue(false),
  enterFullscreen: vi.fn().mockResolvedValue(undefined),
  exitFullscreen: vi.fn().mockResolvedValue(undefined),
  validateKioskPassword: vi.fn().mockResolvedValue(true),
  reportCommandResult: vi.fn().mockResolvedValue(undefined),
  HEARTBEAT_INTERVAL: 30000,
}));

vi.mock('../../../src/services/deviceSyncService', () => ({
  checkDeviceRefreshStatus: vi.fn().mockResolvedValue({ needs_refresh: false }),
  clearDeviceRefreshFlag: vi.fn().mockResolvedValue(true),
}));

vi.mock('../../../src/services/screenshotService', () => ({
  captureAndUploadScreenshot: vi.fn().mockResolvedValue(undefined),
  cleanupOldScreenshots: vi.fn().mockResolvedValue(undefined),
}));

vi.mock('../../../src/services/playerAnalyticsService', () => ({
  startPlaybackEvent: vi.fn(),
  endPlaybackEvent: vi.fn(),
}));

vi.mock('../../../src/hooks/useLogger.js', () => ({
  useLogger: vi.fn().mockReturnValue({
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  }),
}));

// Import hooks after mocks
import { useKioskMode } from '../../../src/player/hooks/useKioskMode.js';
import { usePlayerPlayback } from '../../../src/player/hooks/usePlayerPlayback.js';

describe('useKioskMode', () => {
  beforeEach(() => {
    localStorage.clear();
    vi.clearAllMocks();
  });

  it('initializes with kiosk mode from localStorage', () => {
    localStorage.setItem('player_kiosk_mode', 'true');
    const { result } = renderHook(() => useKioskMode());
    expect(result.current.kioskMode).toBe(true);
  });

  it('shows exit dialog on showKioskExit', () => {
    const { result } = renderHook(() => useKioskMode());
    expect(result.current.showKioskExit).toBe(false);
  });

  it('cancels kiosk exit and clears state', () => {
    const { result } = renderHook(() => useKioskMode());

    act(() => {
      result.current.setKioskPasswordInput('test');
    });

    act(() => {
      result.current.cancelKioskExit();
    });

    expect(result.current.kioskPasswordInput).toBe('');
    expect(result.current.showKioskExit).toBe(false);
  });
});

describe('usePlayerPlayback', () => {
  beforeEach(() => {
    vi.useFakeTimers();
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('provides videoRef for video element', () => {
    const advanceToNext = vi.fn();
    const { result } = renderHook(() =>
      usePlayerPlayback([], 0, null, advanceToNext)
    );
    expect(result.current.videoRef).toBeDefined();
    expect(result.current.videoRef.current).toBeNull();
  });

  it('handleVideoEnd calls advanceToNext', () => {
    const advanceToNext = vi.fn();
    const { result } = renderHook(() =>
      usePlayerPlayback([], 0, null, advanceToNext)
    );

    act(() => {
      result.current.handleVideoEnd();
    });

    expect(advanceToNext).toHaveBeenCalledTimes(1);
  });
});
```

**Run full test suite:**
```bash
npm test -- --run
```

**Verify phase success criteria:**
1. Player.jsx under 500 lines
2. 5 hooks exist and tested
3. All 167+ tests pass
4. Widget components exist
  </action>
  <verify>
```bash
# Run all tests including new hook tests
npm test -- --run

# Verify total test count increased
npm test -- --run 2>&1 | grep -E "Tests|passed|failed"

# Final line count check
wc -l src/Player.jsx
```
  </verify>
  <done>Hook tests pass, all 167+ Player tests pass, Player.jsx under 500 lines, phase complete</done>
</task>

</tasks>

<verification>
1. Player.jsx line count: `wc -l src/Player.jsx` shows < 500 lines
2. All hooks exist: `ls src/player/hooks/` shows 6 files (5 hooks + index)
3. All tests pass: `npm test -- --run`
4. Widgets exist: `ls src/player/components/widgets/` shows 5 files
5. PLR-01 fixed: No getRetryDelay in Player.jsx
</verification>

<success_criteria>
- [ ] Player.jsx is under 500 lines
- [ ] 5 custom hooks extracted (usePlayerContent, usePlayerHeartbeat, usePlayerCommands, useKioskMode, usePlayerPlayback)
- [ ] All hooks have barrel export in src/player/hooks/index.js
- [ ] Hook unit tests exist and pass
- [ ] All 167+ existing Player tests pass
- [ ] Widget components exist in src/player/components/widgets/
- [ ] Offline playback works identically (verified by existing tests)
</success_criteria>

<output>
After completion, create `.planning/phases/07-player-refactoring/07-03-SUMMARY.md`
</output>
