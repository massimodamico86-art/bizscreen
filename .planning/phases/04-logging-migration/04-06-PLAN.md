---
phase: 04-logging-migration
plan: 06
type: execute
wave: 3
depends_on: ["04-02", "04-03", "04-04", "04-05"]
files_modified:
  - src/utils/logger.js
  - eslint.config.js
  - tests/unit/logging.test.js
autonomous: true

must_haves:
  truths:
    - "Zero console.log calls remain in production code paths"
    - "ESLint no-console rule is set to error"
    - "Deprecated logger.js is removed or marked deprecated"
    - "Logging tests verify PII redaction and correlation IDs"
  artifacts:
    - path: "eslint.config.js"
      provides: "ESLint config with no-console error"
      contains: "'no-console': ['error'"
    - path: "tests/unit/logging.test.js"
      provides: "Logging infrastructure tests"
      exports: ["describe('loggingService'"]
  key_links:
    - from: "eslint.config.js"
      to: "npm run lint"
      via: "lint script"
      pattern: "'no-console'.*'error'"
---

<objective>
Verify migration, strengthen enforcement, and clean up deprecated code.

Purpose: Final verification that all success criteria are met. Escalate ESLint rule to error, remove deprecated logger.js, and add tests for logging infrastructure.

Output: Complete Phase 4 with verified zero console.log calls, error-level ESLint enforcement, and logging tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-logging-migration/04-RESEARCH.md
@.planning/phases/04-logging-migration/04-01-SUMMARY.md
@.planning/phases/04-logging-migration/04-02-SUMMARY.md
@.planning/phases/04-logging-migration/04-03-SUMMARY.md
@.planning/phases/04-logging-migration/04-04-SUMMARY.md
@.planning/phases/04-logging-migration/04-05-SUMMARY.md
@eslint.config.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify migration completeness and fix remaining issues</name>
  <files>Any remaining files with console calls</files>
  <action>
1. Run comprehensive scan for remaining console calls:
   ```bash
   grep -r "console\.(log|error|warn|info|debug)" src/ --include="*.js" --include="*.jsx" | \
     grep -v "loggingService.js" | \
     grep -v "node_modules" | \
     grep -v ".test." | \
     grep -v "__mocks__"
   ```

2. Categorize findings:
   - **Missed files**: Migrate using established pattern
   - **Internal logger calls** (in loggingService.js): These are expected - the logger uses console internally
   - **Legitimate console.warn/error**: Review if these should stay (graceful degradation, critical errors before logger is available)

3. Fix any remaining issues:
   - Apply same migration patterns from Plans 03-05
   - Ensure consistency with scoped logger pattern

4. Handle edge cases:
   - Early startup code (before loggingService is initialized)
   - Error boundaries (may need console.error fallback)
   - Build/config scripts (already excluded from ESLint)

5. Verify loggingService.js internal console calls:
   - These should ONLY be in fallback/error paths
   - Example: console.warn in flushLogs catch block is acceptable
   - Verify no console.log exists (only console.warn/error for fallbacks)
  </action>
  <verify>
1. `grep -r "console\.log" src/ --include="*.js" --include="*.jsx" | grep -v loggingService | grep -v node_modules | grep -v test | wc -l`
   Should return 0

2. `grep -r "console\." src/ --include="*.js" --include="*.jsx" | grep -v loggingService | grep -v node_modules | grep -v test | wc -l`
   Should return very small number (only legitimate console.warn/error)
  </verify>
  <done>All production code paths use structured logging, no console.log remains</done>
</task>

<task type="auto">
  <name>Task 2: Escalate ESLint and deprecate old logger</name>
  <files>eslint.config.js, src/utils/logger.js</files>
  <action>
1. Update eslint.config.js:
   - Change no-console rule from 'warn' to 'error':
     ```js
     'no-console': ['error', {
       allow: ['warn', 'error']
     }],
     ```
   - This will now fail CI if console.log is introduced

2. Handle src/utils/logger.js (the old deprecated logger):
   Option A (preferred): Delete the file entirely
   - Check if anything imports it: `grep -r "from.*logger" src/ --include="*.js" --include="*.jsx" | grep -v loggingService`
   - If nothing imports it, delete it
   - If something still imports it, update those imports to use loggingService

   Option B (if deletion is risky): Mark as deprecated
   - Add JSDoc @deprecated comment at top
   - Add console.warn('logger.js is deprecated, use loggingService.js')
   - Export functions that redirect to loggingService

3. Update any remaining imports of old logger to use new loggingService:
   ```js
   // BEFORE
   import { logger } from '../utils/logger.js';
   // AFTER
   import { createScopedLogger } from '../services/loggingService.js';
   const logger = createScopedLogger('ComponentName');
   ```

4. Verify no references to old logger remain:
   ```bash
   grep -r "from.*utils/logger" src/ --include="*.js" --include="*.jsx"
   ```
  </action>
  <verify>
1. `npm run lint` should pass with zero errors (warnings from non-src files are okay)
2. Old logger references eliminated or redirected
3. `npm run build` succeeds
  </verify>
  <done>ESLint rule escalated to error, old logger deprecated/removed</done>
</task>

<task type="auto">
  <name>Task 3: Add logging infrastructure tests</name>
  <files>tests/unit/logging.test.js</files>
  <action>
Create tests/unit/logging.test.js to verify logging infrastructure:

```js
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { redactPII, redactObject, PII_PATTERNS } from '../../src/utils/pii.js';
import { safeStringify } from '../../src/utils/safeStringify.js';

describe('PII Redaction (SEC-05)', () => {
  describe('redactPII', () => {
    it('redacts email addresses', () => {
      const input = 'Contact: user@example.com for info';
      const result = redactPII(input);
      expect(result).toBe('Contact: [EMAIL_REDACTED] for info');
      expect(result).not.toContain('user@example.com');
    });

    it('redacts phone numbers', () => {
      const input = 'Call me at 555-123-4567';
      const result = redactPII(input);
      expect(result).toContain('[PHONE_REDACTED]');
      expect(result).not.toContain('555-123-4567');
    });

    it('redacts credit card numbers', () => {
      const input = 'Card: 4111-1111-1111-1111';
      const result = redactPII(input);
      expect(result).toContain('[CREDITCARD_REDACTED]');
    });

    it('redacts SSN format', () => {
      const input = 'SSN: 123-45-6789';
      const result = redactPII(input);
      expect(result).toContain('[SSN_REDACTED]');
    });

    it('returns non-strings unchanged', () => {
      expect(redactPII(null)).toBeNull();
      expect(redactPII(undefined)).toBeUndefined();
      expect(redactPII(123)).toBe(123);
    });
  });

  describe('redactObject', () => {
    it('redacts sensitive keys', () => {
      const input = { password: 'secret123', username: 'john' };
      const result = redactObject(input);
      expect(result.password).toBe('[REDACTED]');
      expect(result.username).toBe('john');
    });

    it('redacts PII in string values', () => {
      const input = { message: 'User email: test@test.com' };
      const result = redactObject(input);
      expect(result.message).toContain('[EMAIL_REDACTED]');
    });

    it('handles nested objects', () => {
      const input = { user: { email: 'test@test.com', token: 'abc123' } };
      const result = redactObject(input);
      expect(result.user.email).toContain('[EMAIL_REDACTED]');
      expect(result.user.token).toBe('[REDACTED]');
    });

    it('handles arrays', () => {
      const input = { emails: ['a@b.com', 'c@d.com'] };
      const result = redactObject(input);
      expect(result.emails[0]).toContain('[EMAIL_REDACTED]');
      expect(result.emails[1]).toContain('[EMAIL_REDACTED]');
    });

    it('does not mutate original object', () => {
      const input = { password: 'secret' };
      redactObject(input);
      expect(input.password).toBe('secret');
    });
  });
});

describe('Safe Stringify', () => {
  it('handles circular references', () => {
    const obj = { a: 1 };
    obj.self = obj;
    const result = safeStringify(obj);
    expect(result).toContain('[Circular]');
    expect(() => JSON.parse(result.replace('[Circular]', '"[Circular]"'))).not.toThrow();
  });

  it('handles Error objects', () => {
    const error = new Error('Test error');
    const result = safeStringify({ error });
    const parsed = JSON.parse(result);
    expect(parsed.error.name).toBe('Error');
    expect(parsed.error.message).toBe('Test error');
    expect(parsed.error.stack).toBeDefined();
  });

  it('handles null and undefined', () => {
    expect(safeStringify(null)).toBe('null');
    expect(safeStringify({ a: undefined })).toBe('{}'); // JSON.stringify drops undefined
  });

  it('handles deeply nested objects', () => {
    const deep = { a: { b: { c: { d: { e: 'value' } } } } };
    const result = safeStringify(deep);
    expect(result).toContain('value');
  });
});

describe('Logging Service Integration', () => {
  // These tests verify the service is properly configured
  it('exports required functions', async () => {
    const loggingService = await import('../../src/services/loggingService.js');
    expect(loggingService.log).toBeDefined();
    expect(loggingService.createScopedLogger).toBeDefined();
    expect(loggingService.getCorrelationId).toBeDefined();
    expect(loggingService.setLogContext).toBeDefined();
  });

  it('log object has all levels', async () => {
    const { log } = await import('../../src/services/loggingService.js');
    expect(typeof log.trace).toBe('function');
    expect(typeof log.debug).toBe('function');
    expect(typeof log.info).toBe('function');
    expect(typeof log.warn).toBe('function');
    expect(typeof log.error).toBe('function');
    expect(typeof log.fatal).toBe('function');
  });

  it('scoped logger includes scope in messages', async () => {
    const { createScopedLogger } = await import('../../src/services/loggingService.js');
    const logger = createScopedLogger('TestService');
    expect(typeof logger.info).toBe('function');
    // Note: Full integration testing would require mocking console
  });

  it('correlation ID is generated and consistent within session', async () => {
    const { getCorrelationId } = await import('../../src/services/loggingService.js');
    const id1 = getCorrelationId();
    const id2 = getCorrelationId();
    expect(id1).toBe(id2); // Same within session
    expect(id1).toMatch(/^req_\d+_[a-z0-9]+$/); // Expected format
  });
});
```

Run tests: `npm test -- tests/unit/logging.test.js`
  </action>
  <verify>
1. `npm test -- tests/unit/logging.test.js` - all tests pass
2. Test file exists at tests/unit/logging.test.js
  </verify>
  <done>Logging infrastructure has test coverage verifying PII redaction and core functionality</done>
</task>

</tasks>

<verification>
1. Zero console.log in production code:
   `grep -r "console\.log" src/ --include="*.js" --include="*.jsx" | grep -v loggingService | grep -v test | wc -l` = 0

2. ESLint passes with no-console as error:
   `npm run lint` passes (or only shows issues in explicitly excluded files)

3. Old logger removed or deprecated:
   `grep -r "from.*utils/logger" src/ | wc -l` = 0

4. Tests pass:
   `npm test -- tests/unit/logging.test.js` passes

5. Build succeeds:
   `npm run build` succeeds

6. Success criteria from roadmap:
   - Zero console.log in production paths
   - Correlation IDs in logs
   - Log levels applied consistently
   - PII redacted
</verification>

<success_criteria>
- Zero console.log calls in src/ (excluding loggingService internal console.warn/error)
- ESLint no-console rule is 'error' level
- Old src/utils/logger.js removed or deprecated
- tests/unit/logging.test.js exists with passing tests
- All phase 4 success criteria verified:
  1. Zero console.log calls remain in production code paths
  2. Logs include correlation IDs linking related operations
  3. Log levels (error, warn, info, debug) are applied consistently
  4. PII (emails, names) is redacted from log output
</success_criteria>

<output>
After completion, create `.planning/phases/04-logging-migration/04-06-SUMMARY.md`
</output>
