---
phase: 09-device-experience
plan: 08
type: execute
wave: 3
depends_on: ["09-06"]
files_modified:
  - tests/unit/player/useTapSequence.test.jsx
  - tests/unit/player/PinEntry.test.jsx
autonomous: true

must_haves:
  truths:
    - "useTapSequence triggers after 5 consecutive taps"
    - "useTapSequence resets on timeout"
    - "PinEntry validates 4-digit PIN"
    - "PinEntry auto-dismisses on 30s inactivity"
  artifacts:
    - path: "tests/unit/player/useTapSequence.test.jsx"
      provides: "Unit tests for tap sequence hook"
      min_lines: 50
    - path: "tests/unit/player/PinEntry.test.jsx"
      provides: "Unit tests for PIN entry component"
      min_lines: 80
  key_links:
    - from: "useTapSequence.test.jsx"
      to: "useTapSequence"
      via: "import and test"
      pattern: "useTapSequence"
---

<objective>
Create unit tests for Phase 9 player components

Purpose: Verify tap sequence and PIN entry behavior with automated tests
Output: Test files covering core Phase 9 functionality
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-device-experience/09-CONTEXT.md
@src/player/hooks/useTapSequence.js (from 09-02)
@src/player/components/PinEntry.jsx (from 09-03)
@tests/unit/player/Player.hooks.test.jsx (existing test pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useTapSequence tests</name>
  <files>tests/unit/player/useTapSequence.test.jsx</files>
  <action>
Create test file for the tap sequence hook:

```javascript
/**
 * useTapSequence Hook Tests
 *
 * Tests the hidden tap gesture detection hook used for kiosk exit.
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { useTapSequence } from '../../../src/player/hooks/useTapSequence';

describe('useTapSequence', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  describe('basic functionality', () => {
    it('should return handleTap function', () => {
      const { result } = renderHook(() => useTapSequence());
      expect(result.current.handleTap).toBeDefined();
      expect(typeof result.current.handleTap).toBe('function');
    });

    it('should return reset function', () => {
      const { result } = renderHook(() => useTapSequence());
      expect(result.current.reset).toBeDefined();
      expect(typeof result.current.reset).toBe('function');
    });
  });

  describe('tap sequence detection', () => {
    it('should trigger callback after 5 consecutive taps', () => {
      const onTrigger = vi.fn();
      const { result } = renderHook(() =>
        useTapSequence({ requiredTaps: 5, onTrigger })
      );

      // Simulate 5 taps
      for (let i = 0; i < 5; i++) {
        act(() => {
          result.current.handleTap({ type: 'click', preventDefault: vi.fn() });
        });
      }

      expect(onTrigger).toHaveBeenCalledTimes(1);
    });

    it('should not trigger callback before required taps reached', () => {
      const onTrigger = vi.fn();
      const { result } = renderHook(() =>
        useTapSequence({ requiredTaps: 5, onTrigger })
      );

      // Simulate 4 taps (one short)
      for (let i = 0; i < 4; i++) {
        act(() => {
          result.current.handleTap({ type: 'click', preventDefault: vi.fn() });
        });
      }

      expect(onTrigger).not.toHaveBeenCalled();
    });

    it('should support custom tap count', () => {
      const onTrigger = vi.fn();
      const { result } = renderHook(() =>
        useTapSequence({ requiredTaps: 3, onTrigger })
      );

      // Simulate 3 taps
      for (let i = 0; i < 3; i++) {
        act(() => {
          result.current.handleTap({ type: 'click', preventDefault: vi.fn() });
        });
      }

      expect(onTrigger).toHaveBeenCalledTimes(1);
    });
  });

  describe('timeout behavior', () => {
    it('should reset count after timeout between taps', () => {
      const onTrigger = vi.fn();
      const { result } = renderHook(() =>
        useTapSequence({ requiredTaps: 5, timeoutMs: 2000, onTrigger })
      );

      // Tap 3 times
      for (let i = 0; i < 3; i++) {
        act(() => {
          result.current.handleTap({ type: 'click', preventDefault: vi.fn() });
        });
      }

      // Wait longer than timeout
      act(() => {
        vi.advanceTimersByTime(2500);
      });

      // Tap 3 more times (should need all 5 again)
      for (let i = 0; i < 3; i++) {
        act(() => {
          result.current.handleTap({ type: 'click', preventDefault: vi.fn() });
        });
      }

      // Should not trigger (only 3 taps since reset)
      expect(onTrigger).not.toHaveBeenCalled();
    });

    it('should not reset if taps within timeout', () => {
      const onTrigger = vi.fn();
      const { result } = renderHook(() =>
        useTapSequence({ requiredTaps: 5, timeoutMs: 2000, onTrigger })
      );

      // Tap with delays but within timeout
      for (let i = 0; i < 5; i++) {
        act(() => {
          result.current.handleTap({ type: 'click', preventDefault: vi.fn() });
        });
        act(() => {
          vi.advanceTimersByTime(1000); // 1 second between taps (within 2s timeout)
        });
      }

      expect(onTrigger).toHaveBeenCalledTimes(1);
    });

    it('should support custom timeout', () => {
      const onTrigger = vi.fn();
      const { result } = renderHook(() =>
        useTapSequence({ requiredTaps: 3, timeoutMs: 500, onTrigger })
      );

      // Tap once
      act(() => {
        result.current.handleTap({ type: 'click', preventDefault: vi.fn() });
      });

      // Wait 600ms (longer than 500ms timeout)
      act(() => {
        vi.advanceTimersByTime(600);
      });

      // Tap twice more
      for (let i = 0; i < 2; i++) {
        act(() => {
          result.current.handleTap({ type: 'click', preventDefault: vi.fn() });
        });
      }

      // Should not trigger (count reset after timeout)
      expect(onTrigger).not.toHaveBeenCalled();
    });
  });

  describe('reset after trigger', () => {
    it('should reset count after successful trigger', () => {
      const onTrigger = vi.fn();
      const { result } = renderHook(() =>
        useTapSequence({ requiredTaps: 3, onTrigger })
      );

      // Trigger once
      for (let i = 0; i < 3; i++) {
        act(() => {
          result.current.handleTap({ type: 'click', preventDefault: vi.fn() });
        });
      }
      expect(onTrigger).toHaveBeenCalledTimes(1);

      // Trigger again
      for (let i = 0; i < 3; i++) {
        act(() => {
          result.current.handleTap({ type: 'click', preventDefault: vi.fn() });
        });
      }
      expect(onTrigger).toHaveBeenCalledTimes(2);
    });
  });

  describe('manual reset', () => {
    it('should reset count when reset() called', () => {
      const onTrigger = vi.fn();
      const { result } = renderHook(() =>
        useTapSequence({ requiredTaps: 5, onTrigger })
      );

      // Tap 4 times
      for (let i = 0; i < 4; i++) {
        act(() => {
          result.current.handleTap({ type: 'click', preventDefault: vi.fn() });
        });
      }

      // Manual reset
      act(() => {
        result.current.reset();
      });

      // Tap once more (should not trigger - count was reset)
      act(() => {
        result.current.handleTap({ type: 'click', preventDefault: vi.fn() });
      });

      expect(onTrigger).not.toHaveBeenCalled();
    });
  });

  describe('touch event handling', () => {
    it('should call preventDefault on touchend events', () => {
      const { result } = renderHook(() => useTapSequence());
      const preventDefault = vi.fn();

      act(() => {
        result.current.handleTap({ type: 'touchend', preventDefault });
      });

      expect(preventDefault).toHaveBeenCalled();
    });

    it('should not call preventDefault on click events', () => {
      const { result } = renderHook(() => useTapSequence());
      const preventDefault = vi.fn();

      act(() => {
        result.current.handleTap({ type: 'click', preventDefault });
      });

      expect(preventDefault).not.toHaveBeenCalled();
    });
  });
});
```
  </action>
  <verify>File exists and npm test -- tests/unit/player/useTapSequence.test.jsx passes</verify>
  <done>useTapSequence tests cover tap counting, timeout reset, and manual reset</done>
</task>

<task type="auto">
  <name>Task 2: Create PinEntry tests</name>
  <files>tests/unit/player/PinEntry.test.jsx</files>
  <action>
Create test file for the PIN entry component:

```javascript
/**
 * PinEntry Component Tests
 *
 * Tests the full-screen PIN entry component for kiosk exit.
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import { PinEntry } from '../../../src/player/components/PinEntry';

describe('PinEntry', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  describe('rendering', () => {
    it('should render PIN entry screen', () => {
      render(<PinEntry />);
      expect(screen.getByText('Enter PIN')).toBeInTheDocument();
      expect(screen.getByText(/4-digit PIN/)).toBeInTheDocument();
    });

    it('should render numeric keypad', () => {
      render(<PinEntry />);
      // Check all digits 0-9 are present
      for (let i = 0; i <= 9; i++) {
        expect(screen.getByRole('button', { name: i.toString() })).toBeInTheDocument();
      }
    });

    it('should render 4 PIN dots', () => {
      const { container } = render(<PinEntry />);
      // PIN dots are divs with specific styling
      const dots = container.querySelectorAll('[style*="border-radius: 50%"]');
      expect(dots.length).toBe(4);
    });

    it('should render cancel button', () => {
      render(<PinEntry />);
      expect(screen.getByRole('button', { name: /cancel/i })).toBeInTheDocument();
    });
  });

  describe('digit input', () => {
    it('should accept digit button presses', async () => {
      render(<PinEntry />);

      fireEvent.click(screen.getByRole('button', { name: '1' }));
      fireEvent.click(screen.getByRole('button', { name: '2' }));

      // Visual feedback would be filled dots - hard to test directly
      // Instead verify no error state
      expect(screen.queryByText(/incorrect/i)).not.toBeInTheDocument();
    });

    it('should limit input to 4 digits', async () => {
      const onValidate = vi.fn().mockResolvedValue(false);
      render(<PinEntry onValidate={onValidate} />);

      // Press 5 digits
      for (const digit of ['1', '2', '3', '4', '5']) {
        fireEvent.click(screen.getByRole('button', { name: digit }));
      }

      // Should only validate once (after 4th digit)
      await waitFor(() => {
        expect(onValidate).toHaveBeenCalledTimes(1);
      });
      expect(onValidate).toHaveBeenCalledWith('1234');
    });

    it('should support backspace', async () => {
      const onValidate = vi.fn();
      render(<PinEntry onValidate={onValidate} />);

      // Enter 3 digits, backspace, then enter 2 more
      fireEvent.click(screen.getByRole('button', { name: '1' }));
      fireEvent.click(screen.getByRole('button', { name: '2' }));
      fireEvent.click(screen.getByRole('button', { name: '3' }));

      // Click backspace (SVG button)
      const buttons = screen.getAllByRole('button');
      const backspaceBtn = buttons.find(btn =>
        btn.querySelector('svg path[d*="21 4H8"]')
      );
      if (backspaceBtn) {
        fireEvent.click(backspaceBtn);
      }

      fireEvent.click(screen.getByRole('button', { name: '4' }));
      fireEvent.click(screen.getByRole('button', { name: '5' }));

      await waitFor(() => {
        expect(onValidate).toHaveBeenCalledWith('1245');
      });
    });
  });

  describe('validation', () => {
    it('should call onValidate when 4 digits entered', async () => {
      const onValidate = vi.fn().mockResolvedValue(true);
      render(<PinEntry onValidate={onValidate} />);

      for (const digit of ['1', '2', '3', '4']) {
        fireEvent.click(screen.getByRole('button', { name: digit }));
      }

      await waitFor(() => {
        expect(onValidate).toHaveBeenCalledWith('1234');
      });
    });

    it('should call onSuccess when validation succeeds', async () => {
      const onValidate = vi.fn().mockResolvedValue(true);
      const onSuccess = vi.fn();
      render(<PinEntry onValidate={onValidate} onSuccess={onSuccess} />);

      for (const digit of ['1', '2', '3', '4']) {
        fireEvent.click(screen.getByRole('button', { name: digit }));
      }

      await waitFor(() => {
        expect(onSuccess).toHaveBeenCalled();
      });
    });

    it('should show error on invalid PIN', async () => {
      const onValidate = vi.fn().mockResolvedValue(false);
      render(<PinEntry onValidate={onValidate} />);

      for (const digit of ['1', '2', '3', '4']) {
        fireEvent.click(screen.getByRole('button', { name: digit }));
      }

      await waitFor(() => {
        expect(screen.getByText(/incorrect pin/i)).toBeInTheDocument();
      });
    });

    it('should clear PIN after incorrect entry', async () => {
      const onValidate = vi.fn().mockResolvedValue(false);
      render(<PinEntry onValidate={onValidate} />);

      // First attempt
      for (const digit of ['1', '2', '3', '4']) {
        fireEvent.click(screen.getByRole('button', { name: digit }));
      }

      await waitFor(() => {
        expect(screen.getByText(/incorrect pin/i)).toBeInTheDocument();
      });

      // Second attempt should start fresh
      onValidate.mockResolvedValue(true);
      for (const digit of ['5', '6', '7', '8']) {
        fireEvent.click(screen.getByRole('button', { name: digit }));
      }

      await waitFor(() => {
        expect(onValidate).toHaveBeenCalledWith('5678');
      });
    });
  });

  describe('dismissal', () => {
    it('should call onDismiss when cancel clicked', () => {
      const onDismiss = vi.fn();
      render(<PinEntry onDismiss={onDismiss} />);

      fireEvent.click(screen.getByRole('button', { name: /cancel/i }));
      expect(onDismiss).toHaveBeenCalled();
    });

    it('should auto-dismiss after 30 seconds of inactivity', async () => {
      const onDismiss = vi.fn();
      render(<PinEntry onDismiss={onDismiss} />);

      // Advance time by 30 seconds
      act(() => {
        vi.advanceTimersByTime(30000);
      });

      expect(onDismiss).toHaveBeenCalled();
    });

    it('should reset timeout on keypad interaction', async () => {
      const onDismiss = vi.fn();
      render(<PinEntry onDismiss={onDismiss} />);

      // Wait 20 seconds
      act(() => {
        vi.advanceTimersByTime(20000);
      });

      // Press a digit (resets timeout)
      fireEvent.click(screen.getByRole('button', { name: '1' }));

      // Wait another 20 seconds (total 40s, but should be only 20s since reset)
      act(() => {
        vi.advanceTimersByTime(20000);
      });

      expect(onDismiss).not.toHaveBeenCalled();

      // Wait 10 more seconds (total 30s since last interaction)
      act(() => {
        vi.advanceTimersByTime(10000);
      });

      expect(onDismiss).toHaveBeenCalled();
    });
  });
});
```
  </action>
  <verify>File exists and npm test -- tests/unit/player/PinEntry.test.jsx passes (or runs with expected behavior)</verify>
  <done>PinEntry tests cover digit input, validation, error display, and auto-timeout</done>
</task>

</tasks>

<verification>
1. Test files exist:
   - `ls tests/unit/player/useTapSequence.test.jsx`
   - `ls tests/unit/player/PinEntry.test.jsx`
2. Tests run: `npm test -- tests/unit/player/`
3. Build passes: `npm run build`
</verification>

<success_criteria>
- [ ] useTapSequence.test.jsx covers tap counting, timeout reset, manual reset
- [ ] PinEntry.test.jsx covers digit input, validation, error display, auto-timeout
- [ ] Tests follow project patterns (vitest, @testing-library/react)
- [ ] Tests pass or provide coverage for expected behavior
- [ ] Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/09-device-experience/09-08-SUMMARY.md`
</output>
