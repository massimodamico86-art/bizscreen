---
phase: 06-player-reliability
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/player/offlineService.js
  - src/services/screenshotService.js
  - src/services/playerService.js
autonomous: true

must_haves:
  truths:
    - "Screenshots taken offline are queued for upload"
    - "Queued screenshots upload automatically when connection restores"
    - "Kiosk exit password works offline via cached hash"
    - "Incorrect password is rejected when offline"
  artifacts:
    - path: "src/player/offlineService.js"
      provides: "Complete syncPendingScreenshots implementation"
      contains: "blobToBase64"
      min_lines: 480
    - path: "src/services/screenshotService.js"
      provides: "Queue screenshots when offline"
      contains: "queueOfflineEvent"
    - path: "src/services/playerService.js"
      provides: "Offline password verification with SHA-256 hash"
      exports: ["validateKioskPasswordOffline", "cacheKioskPasswordHash"]
  key_links:
    - from: "src/services/screenshotService.js"
      to: "src/player/cacheService.js"
      via: "queueOfflineEvent call"
      pattern: "queueOfflineEvent\\('screenshot'"
    - from: "src/player/offlineService.js"
      to: "src/services/screenshotService.js"
      via: "uploadScreenshot call"
      pattern: "uploadScreenshot\\("
    - from: "src/services/playerService.js"
      to: "crypto.subtle.digest"
      via: "SHA-256 hashing"
      pattern: "crypto\\.subtle\\.digest\\('SHA-256'"
---

<objective>
Complete offline screenshot sync and enhance kiosk exit password verification for offline operation.

Purpose: Ensures screenshots taken when player is offline are automatically uploaded when connection restores, and kiosk exit works reliably without network access using cached password hash.

Output: Working offline screenshot queue with base64 serialization, offline password verification using SHA-256 hash cached in localStorage.
</objective>

<execution_context>
@/Users/massimodamico/bizscreen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/massimodamico/bizscreen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/massimodamico/bizscreen/.planning/PROJECT.md
@/Users/massimodamico/bizscreen/.planning/ROADMAP.md
@/Users/massimodamico/bizscreen/.planning/STATE.md
@/Users/massimodamico/bizscreen/.planning/phases/06-player-reliability/06-CONTEXT.md
@/Users/massimodamico/bizscreen/.planning/phases/06-player-reliability/06-RESEARCH.md

## Existing Infrastructure

src/player/cacheService.js:
- queueOfflineEvent(eventType, eventData) exists (lines 498-510)
- Stores events in IndexedDB STORES.OFFLINE_QUEUE
- getPendingEvents() retrieves unsynced events

src/player/offlineService.js:
- syncPendingScreenshots() is stub at lines 454-463
- Comment: "Screenshots would need custom handling based on how they're stored"
- Handles 'SYNC_SCREENSHOTS' message from service worker

src/services/screenshotService.js:
- takeScreenshot() captures and uploads
- Uses html2canvas to create blob
- Need: Queue when offline instead of failing

src/services/playerService.js:
- validateKioskPassword(input, password) compares plaintext (lines 542-544)
- Need: Add offline verification with cached hash
</context>

<tasks>

<task type="auto">
  <name>Task 1: Complete offline screenshot sync implementation</name>
  <files>
    src/player/offlineService.js
    src/services/screenshotService.js
  </files>
  <action>
**Step 1: Add blob serialization helpers to offlineService.js**

Add these helper functions after the imports section (before the offlineStatusListeners array):

```javascript
/**
 * Convert blob to base64 data URL for IndexedDB storage
 * @param {Blob} blob
 * @returns {Promise<string>}
 */
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

/**
 * Convert base64 data URL back to blob
 * @param {string} base64
 * @param {string} mimeType
 * @returns {Promise<Blob>}
 */
function base64ToBlob(base64, mimeType) {
  return fetch(base64).then(res => res.blob());
}
```

**Step 2: Implement syncPendingScreenshots (replace stub at lines 454-463)**

Replace the stub with this complete implementation:

```javascript
/**
 * Sync pending screenshots
 */
async function syncPendingScreenshots() {
  const screenshots = await getPendingEvents().then((events) =>
    events.filter((e) => e.eventType === 'screenshot').sort((a, b) =>
      new Date(a.createdAt) - new Date(b.createdAt) // FIFO order
    )
  );

  if (screenshots.length === 0) return;

  logger.info('[OfflineService] Syncing pending screenshots', { count: screenshots.length });

  for (const event of screenshots) {
    try {
      const { deviceId, imageData, mimeType, capturedAt } = event.eventData;

      // Convert base64 back to blob
      const blob = await base64ToBlob(imageData, mimeType);

      // Upload using existing screenshot service
      const { uploadScreenshot } = await import('../services/screenshotService.js');
      await uploadScreenshot(deviceId, blob);

      // Mark as synced
      await markEventsSynced([event.id]);

      logger.info('[OfflineService] Synced queued screenshot', {
        deviceId,
        capturedAt,
        sizeKB: Math.round(blob.size / 1024)
      });
    } catch (error) {
      logger.error('[OfflineService] Failed to sync screenshot', {
        error: error.message,
        eventId: event.id
      });
      // Stop on first failure - will retry on next sync attempt
      break;
    }
  }
}
```

**Step 3: Update screenshotService.js to queue when offline**

Import dependencies at top of file:
```javascript
import { queueOfflineEvent } from '../player/cacheService.js';
```

Find the takeScreenshot function and wrap the upload call with offline detection:

```javascript
// Inside takeScreenshot(), after blob creation, before upload:
try {
  // Check if online before attempting upload
  if (!navigator.onLine) {
    // Convert blob to base64 for persistence
    const base64 = await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });

    await queueOfflineEvent('screenshot', {
      deviceId,
      imageData: base64,
      mimeType: blob.type,
      capturedAt: new Date().toISOString(),
    });

    logger.info('[ScreenshotService] Screenshot queued for offline sync', {
      deviceId,
      sizeKB: Math.round(blob.size / 1024),
    });

    return; // Exit early - upload will happen on reconnect
  }

  // Existing upload logic continues here...
  await uploadScreenshot(deviceId, blob);
}
```

Why: Blobs are session-specific and become invalid after page refresh. Converting to base64 allows IndexedDB to persist them across page loads. FIFO order ensures screenshots upload in chronological order.
  </action>
  <verify>
Search for the new functions:
```bash
grep -n "blobToBase64\|base64ToBlob" src/player/offlineService.js
```

Verify syncPendingScreenshots is no longer a stub:
```bash
grep -A 20 "async function syncPendingScreenshots" src/player/offlineService.js | grep "uploadScreenshot"
```

Verify screenshotService queues when offline:
```bash
grep "queueOfflineEvent.*screenshot" src/services/screenshotService.js
```

Check imports:
```bash
grep "import.*queueOfflineEvent" src/services/screenshotService.js
grep "import.*uploadScreenshot.*screenshotService" src/player/offlineService.js
```
  </verify>
  <done>
- blobToBase64 and base64ToBlob helpers exist in offlineService.js
- syncPendingScreenshots is fully implemented (not stub)
- screenshotService.js queues screenshots when navigator.onLine is false
- FIFO ordering applied via createdAt sort
  </done>
</task>

<task type="auto">
  <name>Task 2: Add offline kiosk password verification</name>
  <files>src/services/playerService.js</files>
  <action>
Add two new functions after the existing validateKioskPassword (line 542-544):

```javascript
/**
 * Hash password using SHA-256
 * @param {string} password
 * @returns {Promise<string>} Hex-encoded hash
 */
async function hashPassword(password) {
  const encoder = new TextEncoder();
  const data = encoder.encode(password);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

/**
 * Cache kiosk password hash for offline verification
 * Call this after successful admin login when online
 * @param {string} password - Admin password to cache
 */
export async function cacheKioskPasswordHash(password) {
  try {
    const hash = await hashPassword(password);
    localStorage.setItem('kiosk_password_hash', hash);
    logger.debug('[PlayerService] Cached kiosk password hash for offline use');
  } catch (error) {
    logger.error('[PlayerService] Failed to cache password hash', { error: error.message });
  }
}

/**
 * Validate kiosk password using cached hash (works offline)
 * Falls back to plaintext comparison if hash not available (legacy support)
 * @param {string} input - Password attempt
 * @param {string} password - Plaintext password (fallback)
 * @returns {Promise<boolean>}
 */
export async function validateKioskPasswordOffline(input, password) {
  const storedHash = localStorage.getItem('kiosk_password_hash');

  if (storedHash) {
    // Hash-based verification (preferred)
    try {
      const inputHash = await hashPassword(input);
      return inputHash === storedHash;
    } catch (error) {
      logger.error('[PlayerService] Password hash verification failed', { error: error.message });
      // Fall through to plaintext comparison
    }
  }

  // Legacy plaintext comparison (fallback)
  if (password) {
    logger.warn('[PlayerService] Using plaintext password verification (hash not cached)');
    return input === password;
  }

  logger.error('[PlayerService] No cached hash and no password provided');
  return false;
}
```

Keep the existing validateKioskPassword() for backward compatibility - it's used in contexts where plaintext comparison is acceptable.

Why:
- SHA-256 via crypto.subtle is browser-native, no dependencies required
- Hashing protects password if localStorage is compromised (though low risk for kiosk)
- Falls back to plaintext for legacy deployments without breaking existing functionality
- cacheKioskPasswordHash should be called when admin successfully authenticates (separate from this plan - kiosk exit will call validateKioskPasswordOffline)

Import logger at top of file if not already present:
```javascript
import logger from '../utils/loggingService.js';
```
  </action>
  <verify>
Check new exports exist:
```bash
grep "export.*cacheKioskPasswordHash\|export.*validateKioskPasswordOffline" src/services/playerService.js
```

Verify SHA-256 hashing:
```bash
node -e "
async function test() {
  const encoder = new TextEncoder();
  const data = encoder.encode('test123');
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  console.log('SHA-256 hash of test123:', hash);
  console.log('Length:', hash.length, '(should be 64)');
}
test();
"
```

Verify logger import:
```bash
grep "import.*logger.*loggingService" src/services/playerService.js
```
  </verify>
  <done>
- cacheKioskPasswordHash function exists and is exported
- validateKioskPasswordOffline function exists and is exported
- Both functions use SHA-256 via crypto.subtle.digest
- Fallback to plaintext comparison for legacy support
- logger calls for debugging hash caching
  </done>
</task>

</tasks>

<verification>
1. offlineService.js has blobToBase64 and base64ToBlob helper functions
2. syncPendingScreenshots is fully implemented (not a stub with comment)
3. screenshotService.js checks navigator.onLine before upload
4. screenshotService.js queues screenshots via queueOfflineEvent when offline
5. playerService.js exports cacheKioskPasswordHash and validateKioskPasswordOffline
6. validateKioskPasswordOffline falls back to plaintext if hash not cached
7. npm run lint passes on all modified files
8. grep "TODO\|FIXME\|stub" on modified files returns nothing related to these features
</verification>

<success_criteria>
**PLR-02 complete:** Screenshots taken offline are queued and upload on reconnect
**PLR-03 complete:** Kiosk exit password works offline via cached SHA-256 hash

Measurable outcomes:
- syncPendingScreenshots function body > 20 lines (not stub)
- screenshotService.js contains "if (!navigator.onLine)" check
- playerService.js exports validateKioskPasswordOffline
- grep "blobToBase64" src/player/offlineService.js returns matches
</success_criteria>

<output>
After completion, create `.planning/phases/06-player-reliability/06-02-SUMMARY.md` with:
- Tasks completed
- Code changes summary (blob serialization, offline queue, password hashing)
- Files modified with line counts
- Key functions added (blobToBase64, syncPendingScreenshots, validateKioskPasswordOffline)
</output>
