---
phase: 20-multi-language-core
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/133_language_player_integration.sql
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Player receives language-specific scene variant when device has display_language set"
    - "Player falls back to default language variant when requested language is missing"
    - "Player falls back to original scene when no language group exists"
  artifacts:
    - path: "supabase/migrations/133_language_player_integration.sql"
      provides: "Updated get_resolved_player_content with language resolution"
      contains: "get_scene_for_device_language"
  key_links:
    - from: "get_resolved_player_content"
      to: "get_scene_for_device_language"
      via: "RPC call when resolving scene-based content"
      pattern: "get_scene_for_device_language.*display_language"
---

<objective>
Integrate language resolution into player content resolution RPC

Purpose: Close the critical gap where language variants are created and devices are assigned languages, but the player never receives language-specific content. The `get_scene_for_device_language` RPC exists with proper fallback logic but is never called.

Output: Migration that updates `get_resolved_player_content` to call `get_scene_for_device_language` for all scene-based content resolution, ensuring devices receive content in their configured display language.
</objective>

<execution_context>
@/Users/massimodamico/.claude/get-shit-done/workflows/execute-plan.md
@/Users/massimodamico/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-multi-language-core/20-VERIFICATION.md
@supabase/migrations/126_emergency_content_resolution.sql
@supabase/migrations/132_multi_language_scenes.sql
@supabase/migrations/074_scene_scheduling.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration integrating language resolution into player content RPC</name>
  <files>supabase/migrations/133_language_player_integration.sql</files>
  <action>
Create a new migration that updates `get_resolved_player_content` to integrate language resolution for scene-based content.

**Critical context from migration history:**
- Migration 126 (emergency content) replaced `get_resolved_player_content` and accidentally removed scene-based resolution that was in migration 074
- Migration 132 added `get_scene_for_device_language(scene_id, language_code)` with 3-level fallback
- Migration 132 added `display_language` column to `tv_devices` (defaults to 'en')

**Implementation requirements:**

1. **Start with migration 126 as base** and restore scene-based resolution from migration 074:
   - Step 0: Check `device.active_scene_id` (highest priority, manual override)
   - Step 1: Check `group.active_scene_id` (group override via `screen_groups.active_scene_id`)
   - Step 2: Check scheduled scene via `resolve_scene_schedule()` function
   - (Existing) Step 3: Check active schedule entries (playlist/layout/media)
   - (Existing) Step 4: Fallback to assigned_layout_id
   - (Existing) Step 5: Fallback to assigned_playlist_id

2. **For every scene resolution**, apply language resolution:
   ```sql
   -- Instead of using v_scene.id directly:
   v_resolved_scene_id := get_scene_for_device_language(
     v_scene.id,
     COALESCE(v_device.display_language, 'en')
   );
   -- Then fetch the resolved scene for content
   SELECT * INTO v_scene FROM scenes WHERE id = v_resolved_scene_id;
   ```

3. **Include the `v_device.display_language`** in the device JSON response so the player can verify which language was requested.

4. **Preserve emergency content priority** (from migration 126) - emergency bypasses all including language resolution.

5. **Include a `v_source` field** in the response to indicate content source (device_override, group_override, schedule, assigned_layout, assigned_playlist).

**Structure:**
```sql
-- =====================================================
-- BIZSCREEN: LANGUAGE-AWARE PLAYER CONTENT RESOLUTION
-- =====================================================
-- Integrates language resolution into get_resolved_player_content.
-- Restores scene-based content paths removed in migration 126.
--
-- Resolution order:
-- 1. Emergency content (if active and not expired)
-- 2. Device active_scene_id (manual override) - WITH language resolution
-- 3. Group active_scene_id (group override) - WITH language resolution
-- 4. Scheduled scene (from resolve_scene_schedule) - WITH language resolution
-- 5. Active schedule entries (playlist/layout/media)
-- 6. Assigned layout
-- 7. Assigned playlist
-- =====================================================
```

**Pattern to follow for scene resolution:**
```sql
-- When we have a scene_id from any source:
-- 1. Apply language resolution
v_resolved_scene_id := get_scene_for_device_language(
  v_raw_scene_id,
  COALESCE(v_device.display_language, 'en')
);
-- 2. Fetch the resolved scene
SELECT * INTO v_scene FROM scenes WHERE id = v_resolved_scene_id AND is_active = true;
-- 3. Use v_scene.layout_id or v_scene.primary_playlist_id for content
```

**Key variable additions:**
- `v_resolved_scene_id uuid` - the language-resolved scene ID
- Include `display_language` in device response object

**Important:** The function signature must remain `get_resolved_player_content(p_screen_id UUID) RETURNS JSONB` - do not change the API contract.
  </action>
  <verify>
1. Run `supabase db reset` or `supabase migration up` to apply migration
2. Verify function exists: `SELECT pg_get_functiondef('get_resolved_player_content'::regproc);`
3. Verify language resolution is called by checking function definition contains `get_scene_for_device_language`
4. Test manually with psql:
   ```sql
   -- Create test data if needed
   -- Call the RPC with a device that has display_language set
   SELECT get_resolved_player_content('device-uuid-here');
   -- Verify response includes display_language in device object
   ```
  </verify>
  <done>
- get_resolved_player_content includes scene-based resolution paths (device, group, scheduled)
- Language resolution via get_scene_for_device_language is called for all scene content
- Device response includes display_language field
- Emergency content still has highest priority (unchanged)
- Migration applies cleanly without errors
  </done>
</task>

</tasks>

<verification>
1. Migration applies without errors
2. Function `get_resolved_player_content` contains calls to `get_scene_for_device_language`
3. Device JSON response includes `display_language` field
4. Scene-based content resolution (active_scene_id, group scene, scheduled scene) is restored
5. Language fallback chain works: exact match -> default language -> original scene
</verification>

<success_criteria>
- Migration 133 exists with language-aware player content resolution
- get_resolved_player_content calls get_scene_for_device_language for all scene paths
- Player will receive language-specific variants based on device.display_language
- Fallback to default language works when requested variant is missing
- No breaking changes to existing player behavior
</success_criteria>

<output>
After completion, create `.planning/phases/20-multi-language-core/20-04-SUMMARY.md`
</output>
