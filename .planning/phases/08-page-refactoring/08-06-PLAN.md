---
phase: 08-page-refactoring
plan: 06
type: execute
wave: 2
depends_on: ["08-01", "08-02", "08-03", "08-04", "08-05"]
files_modified:
  - tests/unit/pages/hooks/pageHooks.test.jsx
autonomous: true

must_haves:
  truths:
    - "All 5 page hooks have unit tests"
    - "Hook tests verify data loading behavior"
    - "Hook tests verify state management"
    - "All existing tests still pass"
  artifacts:
    - path: "tests/unit/pages/hooks/pageHooks.test.jsx"
      provides: "Unit tests for page hooks"
      min_lines: 200
  key_links:
    - from: "tests/unit/pages/hooks/pageHooks.test.jsx"
      to: "src/pages/hooks/"
      via: "import hooks for testing"
      pattern: "pages/hooks"
---

<objective>
Create unit tests for extracted page hooks and verify phase completion.

Purpose: Verify all 5 extracted hooks work correctly. Tests follow Phase 7 pattern from Player.hooks.test.jsx. This plan runs after all extraction plans complete.

Output: Hook tests, phase verification, updated documentation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Reference test pattern from Phase 7
@tests/unit/player/Player.hooks.test.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create page hooks unit tests</name>
  <files>
    - tests/unit/pages/hooks/pageHooks.test.jsx
  </files>
  <action>
Create tests/unit/pages/hooks/pageHooks.test.jsx following the Player.hooks.test.jsx pattern.

Test structure:
```javascript
import { renderHook, act, waitFor } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach, beforeAll } from 'vitest';

// Mock services BEFORE imports
vi.mock('../../../../src/services/featureFlagService', () => ({
  getAllFeatureFlags: vi.fn().mockResolvedValue([]),
  createFeatureFlag: vi.fn().mockResolvedValue({ id: '1' }),
  // ... etc
}));

vi.mock('../../../../src/services/campaignService', () => ({
  getCampaign: vi.fn().mockResolvedValue({ id: '1', name: 'Test' }),
  // ... etc
}));

// Similar mocks for other services

// Import hooks AFTER mocks
import { useFeatureFlags } from '../../../../src/pages/hooks/useFeatureFlags';
import { useCampaignEditor } from '../../../../src/pages/hooks/useCampaignEditor';
import { usePlaylistEditor } from '../../../../src/pages/hooks/usePlaylistEditor';
import { useScreensData } from '../../../../src/pages/hooks/useScreensData';
import { useMediaLibrary } from '../../../../src/pages/hooks/useMediaLibrary';

describe('Page Hooks', () => {

  describe('useFeatureFlags', () => {
    beforeEach(() => {
      vi.clearAllMocks();
    });

    it('loads flags on initial render', async () => {
      const { result } = renderHook(() => useFeatureFlags());

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      expect(result.current.flags).toBeDefined();
    });

    it('switches tabs and loads data', async () => {
      const { result } = renderHook(() => useFeatureFlags());

      await act(async () => {
        result.current.setActiveTab('experiments');
      });

      await waitFor(() => {
        expect(result.current.activeTab).toBe('experiments');
      });
    });

    it('handles modal state', () => {
      const { result } = renderHook(() => useFeatureFlags());

      act(() => {
        result.current.setShowFlagModal(true);
      });

      expect(result.current.showFlagModal).toBe(true);
    });
  });

  describe('useCampaignEditor', () => {
    const mockShowToast = vi.fn();

    it('initializes with empty campaign for new', () => {
      const { result } = renderHook(() =>
        useCampaignEditor('new', { showToast: mockShowToast })
      );

      expect(result.current.isNew).toBe(true);
      expect(result.current.campaign.name).toBe('');
    });

    it('loads campaign data for existing id', async () => {
      const { result } = renderHook(() =>
        useCampaignEditor('123', { showToast: mockShowToast })
      );

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });
    });

    it('tracks changes when form modified', () => {
      const { result } = renderHook(() =>
        useCampaignEditor('new', { showToast: mockShowToast })
      );

      act(() => {
        result.current.handleChange('name', 'Test Campaign');
      });

      expect(result.current.hasChanges).toBe(true);
    });
  });

  describe('usePlaylistEditor', () => {
    const mockShowToast = vi.fn();

    it('initializes empty playlist for new', () => {
      const { result } = renderHook(() =>
        usePlaylistEditor('new', { showToast: mockShowToast })
      );

      expect(result.current.isNew).toBe(true);
    });

    it('handles add/remove items', async () => {
      const { result } = renderHook(() =>
        usePlaylistEditor('new', { showToast: mockShowToast })
      );

      const mockMedia = { id: '1', name: 'Test Media' };

      await act(async () => {
        await result.current.handleAddItem(mockMedia);
      });

      // Verify item added to playlist
    });
  });

  describe('useScreensData', () => {
    const mockShowToast = vi.fn();

    it('loads screens on mount', async () => {
      const { result } = renderHook(() =>
        useScreensData({ showToast: mockShowToast })
      );

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      expect(result.current.screens).toBeDefined();
    });

    it('filters screens by search', async () => {
      const { result } = renderHook(() =>
        useScreensData({ showToast: mockShowToast })
      );

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });

      act(() => {
        result.current.setSearch('test');
      });

      // filteredScreens should be computed based on search
    });
  });

  describe('useMediaLibrary', () => {
    const mockShowToast = vi.fn();

    it('loads media assets on mount', async () => {
      const { result } = renderHook(() =>
        useMediaLibrary({ showToast: mockShowToast })
      );

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });
    });

    it('handles bulk selection', () => {
      const { result } = renderHook(() =>
        useMediaLibrary({ showToast: mockShowToast })
      );

      act(() => {
        result.current.toggleSelection('asset-1');
        result.current.toggleSelection('asset-2');
      });

      expect(result.current.selectedCount).toBe(2);
      expect(result.current.hasSelection).toBe(true);

      act(() => {
        result.current.clearSelection();
      });

      expect(result.current.selectedCount).toBe(0);
    });

    it('changes view mode', () => {
      const { result } = renderHook(() =>
        useMediaLibrary({ showToast: mockShowToast })
      );

      act(() => {
        result.current.setViewMode('list');
      });

      expect(result.current.viewMode).toBe('list');
    });
  });

});
```

Write comprehensive tests covering:
- Initial state
- Data loading
- State updates (setters)
- Action handlers (at least smoke tests)
- Modal state management
  </action>
  <verify>
    - tests/unit/pages/hooks/pageHooks.test.jsx exists
    - File contains tests for all 5 hooks
    - `npm test tests/unit/pages/hooks/pageHooks.test.jsx` passes
  </verify>
  <done>
    - Unit tests created for all 5 page hooks
    - Tests verify data loading, state management, actions
  </done>
</task>

<task type="auto">
  <name>Task 2: Run full test suite and verify phase metrics</name>
  <files>None (verification only)</files>
  <action>
1. Run all tests:
```bash
npm test -- --run
```

2. Verify final line counts:
```bash
wc -l src/pages/FeatureFlagsPage.jsx src/pages/CampaignEditorPage.jsx src/pages/PlaylistEditorPage.jsx src/pages/ScreensPage.jsx src/pages/MediaLibraryPage.jsx
```

3. Verify hooks exist and have expected size:
```bash
wc -l src/pages/hooks/*.js
```

4. Verify barrel export contains all hooks:
```bash
cat src/pages/hooks/index.js
```

5. Summarize results:
- Original total: 9122 lines across 5 pages
- Target: ~2500 lines (5 x ~500)
- Calculate actual reduction percentage

Document any pages that couldn't meet the 500 line target and why (complex inline UI, etc.).
  </action>
  <verify>
    - Test suite passes (allow pre-existing failures)
    - All 5 pages are significantly reduced
    - All 5 hooks exist in src/pages/hooks/
    - Barrel export has all 5 hooks
  </verify>
  <done>
    - Full test suite verified
    - Phase metrics documented
    - Line reduction targets assessed
  </done>
</task>

</tasks>

<verification>
1. Test file exists: `ls tests/unit/pages/hooks/pageHooks.test.jsx`
2. Tests pass: `npm test tests/unit/pages/hooks/pageHooks.test.jsx`
3. All hooks exported: `grep -c "export" src/pages/hooks/index.js` shows 5
4. Page line counts all reduced: `wc -l src/pages/{FeatureFlags,CampaignEditor,PlaylistEditor,Screens,MediaLibrary}Page.jsx`
</verification>

<success_criteria>
- Unit tests exist for all 5 page hooks
- All tests pass
- All 5 pages significantly reduced from original line counts
- src/pages/hooks/ barrel export contains all 5 hooks
- Phase 8 requirements (REF-03 through REF-07) addressed
</success_criteria>

<output>
After completion, create `.planning/phases/08-page-refactoring/08-06-SUMMARY.md`
</output>
