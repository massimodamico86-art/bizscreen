---
phase: 12-content-approval
plan: 07
type: execute
wave: 3
depends_on: ["12-01"]
files_modified:
  - src/services/scheduleService.js
  - src/pages/ScheduleEditorPage.jsx
  - src/services/playlistService.js
  - src/services/sceneService.js
autonomous: true

must_haves:
  truths:
    - "Unapproved playlists/scenes cannot be assigned to schedules by editors"
    - "Owners/managers can still assign any content regardless of status"
    - "UI indicates content awaiting approval"
  artifacts:
    - path: "src/services/scheduleService.js"
      provides: "Content assignment validation"
      contains: "approval_status"
    - path: "src/pages/ScheduleEditorPage.jsx"
      provides: "Approval status display in content picker"
      contains: "approval_status"
  key_links:
    - from: "src/pages/ScheduleEditorPage.jsx"
      to: "src/services/permissionsService.js"
      via: "requiresApproval check"
      pattern: "requiresApproval"
---

<objective>
Block unapproved content from being assigned to screens/schedules.

Purpose: Per APR-04, rejected content cannot be published to screens. Content must be approved before editors can assign it to schedules. Owners/managers bypass this check.

Output: Schedule assignment validates approval status; UI shows content status.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-content-approval/12-RESEARCH.md
@.planning/phases/12-content-approval/12-01-SUMMARY.md

# Schedule and content services
@src/services/scheduleService.js
@src/services/playlistService.js
@src/services/sceneService.js
@src/services/permissionsService.js
@src/pages/ScheduleEditorPage.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add content assignment validation to scheduleService with wiring</name>
  <files>src/services/scheduleService.js</files>
  <action>
Add validation function and wire it into schedule entry creation/update:

1. Add imports at top:
```javascript
import { requiresApproval } from './permissionsService.js';
import { APPROVAL_STATUS } from './approvalService.js';
```

2. Add validation function:
```javascript
/**
 * Check if content can be assigned to a schedule
 * Editors can only assign approved content; owners/managers can assign anything
 *
 * @param {string} contentType - 'playlist' or 'scene'
 * @param {string} contentId - Content ID
 * @returns {Promise<{canAssign: boolean, reason?: string}>}
 */
export async function canAssignContent(contentType, contentId) {
  // Check if user requires approval (editors/viewers do, owners/managers don't)
  const needsApprovalCheck = await requiresApproval();

  if (!needsApprovalCheck) {
    // Owners/managers can assign any content
    return { canAssign: true };
  }

  // Editors need to check approval status
  const tableName = contentType === 'playlist' ? 'playlists' : 'scenes';
  const { data, error } = await supabase
    .from(tableName)
    .select('approval_status')
    .eq('id', contentId)
    .single();

  if (error) {
    return { canAssign: false, reason: 'Unable to verify content status' };
  }

  // Only approved content can be assigned by editors
  if (data.approval_status !== APPROVAL_STATUS.APPROVED) {
    const statusLabels = {
      draft: 'pending submission',
      in_review: 'awaiting approval',
      rejected: 'needs revision',
    };
    const statusLabel = statusLabels[data.approval_status] || data.approval_status;
    return {
      canAssign: false,
      reason: `This content is ${statusLabel}. Only approved content can be scheduled.`,
    };
  }

  return { canAssign: true };
}
```

3. Wire canAssignContent into createScheduleEntry (around line 264):

Find the createScheduleEntry function and add validation BEFORE the insert:
```javascript
export async function createScheduleEntry(scheduleId, entryData = {}) {
  // Validate content can be assigned (approval check for editors)
  const contentType = entryData.content_type || entryData.target_type;
  const contentId = entryData.content_id || entryData.target_id;

  if (contentType && contentId && (contentType === 'playlist' || contentType === 'scene')) {
    const { canAssign, reason } = await canAssignContent(contentType, contentId);
    if (!canAssign) {
      throw new Error(reason);
    }
  }

  // ... rest of existing createScheduleEntry code
```

4. Wire canAssignContent into updateScheduleEntry (around line 308):

Add validation when content_id is being changed:
```javascript
export async function updateScheduleEntry(entryId, updates) {
  // Validate content can be assigned if content is being changed
  const contentType = updates.content_type;
  const contentId = updates.content_id;

  if (contentType && contentId && (contentType === 'playlist' || contentType === 'scene')) {
    const { canAssign, reason } = await canAssignContent(contentType, contentId);
    if (!canAssign) {
      throw new Error(reason);
    }
  }

  // ... rest of existing updateScheduleEntry code
```

5. Wire canAssignContent into updateScheduleFillerContent (around line 590):

Add validation for filler content:
```javascript
export async function updateScheduleFillerContent(scheduleId, contentType, contentId) {
  if (!scheduleId) throw new Error('Schedule ID is required');
  if (!contentType || !contentId) throw new Error('Content type and ID are required');

  // Validate content can be assigned (approval check for editors)
  if (contentType === 'playlist' || contentType === 'scene') {
    const { canAssign, reason } = await canAssignContent(contentType, contentId);
    if (!canAssign) {
      throw new Error(reason);
    }
  }

  // ... rest of existing updateScheduleFillerContent code
```

6. Update getScenesForSchedule (line 545) to include approval_status:
```javascript
export async function getScenesForSchedule() {
  const { data, error } = await supabase
    .from('scenes')
    .select('id, name, business_type, is_active, approval_status')
    .eq('is_active', true)
    .order('name');

  if (error) throw error;
  return data || [];
}
```
  </action>
  <verify>
Run these checks:
1. `grep -n "canAssignContent" src/services/scheduleService.js` - function must exist AND be called in createScheduleEntry, updateScheduleEntry, updateScheduleFillerContent
2. `grep -c "canAssignContent" src/services/scheduleService.js` - must return 4 or more (1 definition + 3 calls minimum)
3. `grep "approval_status" src/services/scheduleService.js | grep getScenesForSchedule` - getScenesForSchedule select must include approval_status
  </verify>
  <done>
- canAssignContent function exists in scheduleService.js
- createScheduleEntry calls canAssignContent before insert
- updateScheduleEntry calls canAssignContent when content_id changes
- updateScheduleFillerContent calls canAssignContent before update
- getScenesForSchedule includes approval_status in select
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ScheduleEditorPage content picker</name>
  <files>src/pages/ScheduleEditorPage.jsx</files>
  <action>
First, read ScheduleEditorPage.jsx to understand its structure.

Then update the content picker/selector to show approval status and restrict selection:

1. Add imports:
```javascript
import { requiresApproval } from '../services/permissionsService.js';
import { APPROVAL_STATUS, getApprovalStatusConfig } from '../services/approvalService.js';
```

2. Add state for user's approval requirement:
```javascript
const [userRequiresApproval, setUserRequiresApproval] = useState(false);

useEffect(() => {
  requiresApproval().then(setUserRequiresApproval);
}, []);
```

3. In the content picker (where playlists/scenes are listed for selection), modify the item rendering to:

a) Show approval status badge:
```jsx
{item.approval_status && item.approval_status !== 'approved' && userRequiresApproval && (
  <Badge
    variant={getApprovalStatusConfig(item.approval_status).variant}
    className="ml-2 text-xs"
  >
    {getApprovalStatusConfig(item.approval_status).label}
  </Badge>
)}
```

b) Disable selection for non-approved content (for editors):
```jsx
<button
  onClick={() => handleSelectContent(item)}
  disabled={userRequiresApproval && item.approval_status !== 'approved' && item.approval_status !== undefined}
  className={`... ${userRequiresApproval && item.approval_status !== 'approved' ? 'opacity-50 cursor-not-allowed' : ''}`}
>
```

c) Add tooltip or helper text explaining why content is disabled:
```jsx
{userRequiresApproval && item.approval_status !== 'approved' && (
  <span className="text-xs text-gray-500 ml-2">
    (Needs approval)
  </span>
)}
```

The exact implementation depends on how the content picker is structured (modal, dropdown, inline list, etc.). Look for where content items are rendered and add the status indication and selection restriction.
  </action>
  <verify>grep for "approval_status" and "userRequiresApproval" in ScheduleEditorPage.jsx</verify>
  <done>Content picker shows approval status and restricts unapproved content for editors</done>
</task>

<task type="auto">
  <name>Task 3: Ensure content queries include approval_status field</name>
  <files>src/services/playlistService.js, src/services/sceneService.js</files>
  <action>
Most fetch functions use `*` in their select, so approval_status will be included automatically once the column exists. Verify and update any functions with explicit field lists.

**For playlistService.js:**

1. Check fetchPlaylists (line 47): Uses `*` - OK, no change needed
2. Check getPlaylist (line 69): Uses `*` - OK, no change needed

No changes needed for playlistService.js since it uses `*` in selects.

**For sceneService.js:**

1. Check fetchScenesForTenant (line 69): Uses `*` - OK, no change needed
2. Check fetchScene (line 105): Uses `*` - OK, no change needed
3. Check fetchScenesWithDeviceCounts (line 270): Uses RPC, may need RPC update if approval_status needed

If the RPC `get_scenes_with_device_counts` needs to return approval_status, that would require a migration. For now, the main scene queries use `*` which will include approval_status.

**Already handled in Task 1:**
- getScenesForSchedule in scheduleService.js - updated to include approval_status explicitly (since it has explicit field list)

Verify that queries using explicit field lists include approval_status:
- scheduleService.js getScenesForSchedule: Updated in Task 1
- Any other explicit select lists in playlistService/sceneService: None found (all use `*`)
  </action>
  <verify>
Run these verification commands:
1. `grep -n "\.select(" src/services/playlistService.js | head -5` - confirm uses `*`
2. `grep -n "\.select(" src/services/sceneService.js | head -5` - confirm uses `*`
3. `grep "approval_status" src/services/scheduleService.js | grep -c getScenesForSchedule` - must return 1 (from Task 1)

The functions using explicit field lists:
- getScenesForSchedule (scheduleService.js): Must include approval_status - verified in Task 1

Functions using `*` that auto-include approval_status:
- fetchPlaylists (playlistService.js): Uses `*`
- getPlaylist (playlistService.js): Uses `*`
- fetchScenesForTenant (sceneService.js): Uses `*`
- fetchScene (sceneService.js): Uses `*`
  </verify>
  <done>
- playlistService.js functions use `*` - approval_status auto-included
- sceneService.js functions use `*` - approval_status auto-included
- getScenesForSchedule has explicit approval_status in select (from Task 1)
  </done>
</task>

</tasks>

<verification>
1. canAssignContent function exists in scheduleService.js
2. canAssignContent is called in createScheduleEntry, updateScheduleEntry, updateScheduleFillerContent (grep count >= 4)
3. getScenesForSchedule includes approval_status in its select clause
4. ScheduleEditorPage shows approval status badges
5. Unapproved content is disabled/restricted for editors
6. Owners/managers can still select any content
</verification>

<success_criteria>
- Rejected content cannot be published to screens (APR-04)
- Editors see approval status and cannot select unapproved content
- Owners/managers can assign any content regardless of status
- Clear UI indication of content that needs approval
</success_criteria>

<output>
After completion, create `.planning/phases/12-content-approval/12-07-SUMMARY.md`
</output>
