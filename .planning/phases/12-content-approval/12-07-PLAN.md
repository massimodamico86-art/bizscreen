---
phase: 12-content-approval
plan: 07
type: execute
wave: 3
depends_on: ["12-01"]
files_modified:
  - src/services/scheduleService.js
  - src/pages/ScheduleEditorPage.jsx
autonomous: true

must_haves:
  truths:
    - "Unapproved playlists/scenes cannot be assigned to schedules by editors"
    - "Owners/managers can still assign any content regardless of status"
    - "UI indicates content awaiting approval"
  artifacts:
    - path: "src/services/scheduleService.js"
      provides: "Content assignment validation"
      contains: "approval_status"
    - path: "src/pages/ScheduleEditorPage.jsx"
      provides: "Approval status display in content picker"
      contains: "approval_status"
  key_links:
    - from: "src/pages/ScheduleEditorPage.jsx"
      to: "src/services/permissionsService.js"
      via: "requiresApproval check"
      pattern: "requiresApproval"
---

<objective>
Block unapproved content from being assigned to screens/schedules.

Purpose: Per APR-04, rejected content cannot be published to screens. Content must be approved before editors can assign it to schedules. Owners/managers bypass this check.

Output: Schedule assignment validates approval status; UI shows content status.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-content-approval/12-RESEARCH.md
@.planning/phases/12-content-approval/12-01-SUMMARY.md

# Schedule and content services
@src/services/scheduleService.js
@src/services/playlistService.js
@src/services/sceneService.js
@src/services/permissionsService.js
@src/pages/ScheduleEditorPage.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add content assignment validation to scheduleService</name>
  <files>src/services/scheduleService.js</files>
  <action>
Add validation function to scheduleService.js that checks approval status before allowing content assignment:

1. Add imports at top:
```javascript
import { requiresApproval } from './permissionsService.js';
import { APPROVAL_STATUS } from './approvalService.js';
```

2. Add validation function:
```javascript
/**
 * Check if content can be assigned to a schedule
 * Editors can only assign approved content; owners/managers can assign anything
 *
 * @param {string} contentType - 'playlist' or 'scene'
 * @param {string} contentId - Content ID
 * @returns {Promise<{canAssign: boolean, reason?: string}>}
 */
export async function canAssignContent(contentType, contentId) {
  // Check if user requires approval (editors/viewers do, owners/managers don't)
  const needsApprovalCheck = await requiresApproval();

  if (!needsApprovalCheck) {
    // Owners/managers can assign any content
    return { canAssign: true };
  }

  // Editors need to check approval status
  const tableName = contentType === 'playlist' ? 'playlists' : 'scenes';
  const { data, error } = await supabase
    .from(tableName)
    .select('approval_status')
    .eq('id', contentId)
    .single();

  if (error) {
    return { canAssign: false, reason: 'Unable to verify content status' };
  }

  // Only approved content can be assigned by editors
  if (data.approval_status !== APPROVAL_STATUS.APPROVED) {
    const statusLabels = {
      draft: 'pending submission',
      in_review: 'awaiting approval',
      rejected: 'needs revision',
    };
    const statusLabel = statusLabels[data.approval_status] || data.approval_status;
    return {
      canAssign: false,
      reason: `This content is ${statusLabel}. Only approved content can be scheduled.`,
    };
  }

  return { canAssign: true };
}
```

3. Update existing schedule assignment functions (if they exist) to call canAssignContent:

If there's a function like `assignContentToScheduleEntry` or similar, add validation:

```javascript
export async function assignContentToScheduleEntry(entryId, contentType, contentId) {
  // Validate content can be assigned
  const { canAssign, reason } = await canAssignContent(contentType, contentId);
  if (!canAssign) {
    throw new Error(reason);
  }

  // Proceed with assignment
  // ... existing logic
}
```
  </action>
  <verify>grep for "canAssignContent" and "APPROVAL_STATUS" in scheduleService.js</verify>
  <done>Schedule service validates approval status before content assignment</done>
</task>

<task type="auto">
  <name>Task 2: Update ScheduleEditorPage content picker</name>
  <files>src/pages/ScheduleEditorPage.jsx</files>
  <action>
First, read ScheduleEditorPage.jsx to understand its structure.

Then update the content picker/selector to show approval status and restrict selection:

1. Add imports:
```javascript
import { requiresApproval } from '../services/permissionsService.js';
import { APPROVAL_STATUS, getApprovalStatusConfig } from '../services/approvalService.js';
```

2. Add state for user's approval requirement:
```javascript
const [userRequiresApproval, setUserRequiresApproval] = useState(false);

useEffect(() => {
  requiresApproval().then(setUserRequiresApproval);
}, []);
```

3. In the content picker (where playlists/scenes are listed for selection), modify the item rendering to:

a) Show approval status badge:
```jsx
{item.approval_status && item.approval_status !== 'approved' && userRequiresApproval && (
  <Badge
    variant={getApprovalStatusConfig(item.approval_status).variant}
    className="ml-2 text-xs"
  >
    {getApprovalStatusConfig(item.approval_status).label}
  </Badge>
)}
```

b) Disable selection for non-approved content (for editors):
```jsx
<button
  onClick={() => handleSelectContent(item)}
  disabled={userRequiresApproval && item.approval_status !== 'approved' && item.approval_status !== undefined}
  className={`... ${userRequiresApproval && item.approval_status !== 'approved' ? 'opacity-50 cursor-not-allowed' : ''}`}
>
```

c) Add tooltip or helper text explaining why content is disabled:
```jsx
{userRequiresApproval && item.approval_status !== 'approved' && (
  <span className="text-xs text-gray-500 ml-2">
    (Needs approval)
  </span>
)}
```

The exact implementation depends on how the content picker is structured (modal, dropdown, inline list, etc.). Look for where content items are rendered and add the status indication and selection restriction.
  </action>
  <verify>grep for "approval_status" and "userRequiresApproval" in ScheduleEditorPage.jsx</verify>
  <done>Content picker shows approval status and restricts unapproved content for editors</done>
</task>

<task type="auto">
  <name>Task 3: Update content queries to include approval_status</name>
  <files>src/services/playlistService.js</files>
  <action>
Ensure content queries return approval_status so the UI can display it:

1. Check existing fetch functions (e.g., fetchPlaylists, fetchPlaylistsForPicker) and add approval_status to select if missing:

```javascript
// Example: If there's a fetchPlaylistsForPicker or similar
export async function fetchPlaylistsForPicker(tenantId) {
  const { data, error } = await supabase
    .from('playlists')
    .select(`
      id,
      name,
      description,
      approval_status,
      // ... other needed fields
    `)
    .eq('owner_id', tenantId)
    .order('name');

  if (error) throw error;
  return data || [];
}
```

2. Similarly check sceneService.js and ensure scene queries return approval_status.

The goal is to ensure any content picker in the schedule editor has access to approval_status field for each item.

Note: If approval_status is already included in existing queries (check the current select statements), no change needed. Just verify the field is available.
  </action>
  <verify>grep for "approval_status" in select queries in playlistService.js and sceneService.js</verify>
  <done>Content queries include approval_status field for UI display</done>
</task>

</tasks>

<verification>
1. canAssignContent function exists in scheduleService.js
2. ScheduleEditorPage shows approval status badges
3. Unapproved content is disabled/restricted for editors
4. Owners/managers can still select any content
5. Content queries include approval_status field
</verification>

<success_criteria>
- Rejected content cannot be published to screens (APR-04)
- Editors see approval status and cannot select unapproved content
- Owners/managers can assign any content regardless of status
- Clear UI indication of content that needs approval
</success_criteria>

<output>
After completion, create `.planning/phases/12-content-approval/12-07-SUMMARY.md`
</output>
