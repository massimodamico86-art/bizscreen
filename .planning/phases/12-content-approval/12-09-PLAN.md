---
phase: 12-content-approval
plan: 09
type: execute
wave: 4
depends_on: ["12-03", "12-04", "12-05", "12-06", "12-07", "12-08"]
files_modified:
  - tests/unit/approvalService.test.js
  - tests/unit/permissionsService.test.js
autonomous: true

must_haves:
  truths:
    - "requiresApproval returns correct value for each role"
    - "savePlaylistWithApproval creates review request when needed"
    - "saveSceneWithApproval creates review request when needed"
  artifacts:
    - path: "tests/unit/approvalService.test.js"
      provides: "Tests for approval workflow functions"
      min_lines: 80
    - path: "tests/unit/permissionsService.test.js"
      provides: "Tests for requiresApproval function"
      min_lines: 40
  key_links:
    - from: "tests/unit/approvalService.test.js"
      to: "src/services/approvalService.js"
      via: "function imports"
      pattern: "import.*approvalService"
---

<objective>
Test the content approval workflow implementation.

Purpose: Verify that APR-01 through APR-05 success criteria are met through unit tests. Focus on the new role-based logic and auto-submit behavior.

Output: Test files covering requiresApproval, savePlaylistWithApproval, and saveSceneWithApproval.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-content-approval/12-RESEARCH.md
@.planning/phases/12-content-approval/12-01-SUMMARY.md
@.planning/phases/12-content-approval/12-03-SUMMARY.md
@.planning/phases/12-content-approval/12-04-SUMMARY.md

# Services under test
@src/services/approvalService.js
@src/services/permissionsService.js
@src/services/playlistService.js
@src/services/sceneService.js

# Existing test patterns
@tests/unit/
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create/extend permissionsService tests</name>
  <files>tests/unit/permissionsService.test.js</files>
  <action>
Create or extend tests/unit/permissionsService.test.js to test requiresApproval and canApproveContent:

```javascript
import { describe, it, expect, vi, beforeEach } from 'vitest';

// Mock supabase
vi.mock('../../src/supabase', () => ({
  supabase: {
    auth: {
      getUser: vi.fn(),
    },
    from: vi.fn(() => ({
      select: vi.fn().mockReturnThis(),
      eq: vi.fn().mockReturnThis(),
      single: vi.fn(),
    })),
  },
}));

// Mock tenantService
vi.mock('../../src/services/tenantService', () => ({
  getEffectiveOwnerId: vi.fn(),
  isImpersonating: vi.fn(() => false),
}));

import { supabase } from '../../src/supabase';
import { getEffectiveOwnerId } from '../../src/services/tenantService';
import {
  requiresApproval,
  canApproveContent,
  getCurrentMemberRole,
  clearPermissionsCache,
} from '../../src/services/permissionsService';

describe('permissionsService', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    clearPermissionsCache();
  });

  describe('requiresApproval', () => {
    it('returns false for super_admin', async () => {
      supabase.auth.getUser.mockResolvedValue({ data: { user: { id: 'user-1' } } });
      supabase.from.mockReturnValue({
        select: vi.fn().mockReturnThis(),
        eq: vi.fn().mockReturnThis(),
        single: vi.fn().mockResolvedValue({ data: { role: 'super_admin' }, error: null }),
      });

      const result = await requiresApproval();
      expect(result).toBe(false);
    });

    it('returns false for admin', async () => {
      supabase.auth.getUser.mockResolvedValue({ data: { user: { id: 'user-1' } } });
      supabase.from.mockReturnValue({
        select: vi.fn().mockReturnThis(),
        eq: vi.fn().mockReturnThis(),
        single: vi.fn().mockResolvedValue({ data: { role: 'admin' }, error: null }),
      });

      const result = await requiresApproval();
      expect(result).toBe(false);
    });

    it('returns false for owner', async () => {
      const userId = 'tenant-owner-1';
      supabase.auth.getUser.mockResolvedValue({ data: { user: { id: userId } } });
      getEffectiveOwnerId.mockResolvedValue(userId); // User is the tenant owner

      // Profile query for role check
      supabase.from.mockReturnValue({
        select: vi.fn().mockReturnThis(),
        eq: vi.fn().mockReturnThis(),
        single: vi.fn().mockResolvedValue({ data: { role: 'client' }, error: null }),
      });

      const result = await requiresApproval();
      expect(result).toBe(false);
    });

    it('returns false for manager', async () => {
      supabase.auth.getUser.mockResolvedValue({ data: { user: { id: 'user-1' } } });
      getEffectiveOwnerId.mockResolvedValue('tenant-1');

      // First call for profile role
      const profileMock = {
        select: vi.fn().mockReturnThis(),
        eq: vi.fn().mockReturnThis(),
        single: vi.fn().mockResolvedValue({ data: { role: 'client' }, error: null }),
      };

      // Second call for organization member role
      const orgMemberMock = {
        select: vi.fn().mockReturnThis(),
        eq: vi.fn().mockReturnThis(),
        single: vi.fn().mockResolvedValue({ data: { role: 'manager' }, error: null }),
      };

      supabase.from
        .mockReturnValueOnce(profileMock)
        .mockReturnValueOnce(orgMemberMock);

      const result = await requiresApproval();
      expect(result).toBe(false);
    });

    it('returns true for editor', async () => {
      supabase.auth.getUser.mockResolvedValue({ data: { user: { id: 'user-1' } } });
      getEffectiveOwnerId.mockResolvedValue('tenant-1');

      supabase.from.mockReturnValue({
        select: vi.fn().mockReturnThis(),
        eq: vi.fn().mockReturnThis(),
        single: vi.fn()
          .mockResolvedValueOnce({ data: { role: 'client' }, error: null }) // profile
          .mockResolvedValueOnce({ data: { role: 'editor' }, error: null }), // org member
      });

      const result = await requiresApproval();
      expect(result).toBe(true);
    });

    it('returns true for viewer', async () => {
      supabase.auth.getUser.mockResolvedValue({ data: { user: { id: 'user-1' } } });
      getEffectiveOwnerId.mockResolvedValue('tenant-1');

      supabase.from.mockReturnValue({
        select: vi.fn().mockReturnThis(),
        eq: vi.fn().mockReturnThis(),
        single: vi.fn()
          .mockResolvedValueOnce({ data: { role: 'client' }, error: null })
          .mockResolvedValueOnce({ data: { role: 'viewer' }, error: null }),
      });

      const result = await requiresApproval();
      expect(result).toBe(true);
    });
  });

  describe('canApproveContent', () => {
    it('returns true for owner', async () => {
      const userId = 'tenant-owner-1';
      supabase.auth.getUser.mockResolvedValue({ data: { user: { id: userId } } });
      getEffectiveOwnerId.mockResolvedValue(userId);

      supabase.from.mockReturnValue({
        select: vi.fn().mockReturnThis(),
        eq: vi.fn().mockReturnThis(),
        single: vi.fn().mockResolvedValue({ data: { role: 'client' }, error: null }),
      });

      const result = await canApproveContent();
      expect(result).toBe(true);
    });

    it('returns true for manager', async () => {
      supabase.auth.getUser.mockResolvedValue({ data: { user: { id: 'user-1' } } });
      getEffectiveOwnerId.mockResolvedValue('tenant-1');

      supabase.from.mockReturnValue({
        select: vi.fn().mockReturnThis(),
        eq: vi.fn().mockReturnThis(),
        single: vi.fn()
          .mockResolvedValueOnce({ data: { role: 'client' }, error: null })
          .mockResolvedValueOnce({ data: { role: 'manager' }, error: null }),
      });

      const result = await canApproveContent();
      expect(result).toBe(true);
    });

    it('returns false for editor', async () => {
      supabase.auth.getUser.mockResolvedValue({ data: { user: { id: 'user-1' } } });
      getEffectiveOwnerId.mockResolvedValue('tenant-1');

      supabase.from.mockReturnValue({
        select: vi.fn().mockReturnThis(),
        eq: vi.fn().mockReturnThis(),
        single: vi.fn()
          .mockResolvedValueOnce({ data: { role: 'client' }, error: null })
          .mockResolvedValueOnce({ data: { role: 'editor' }, error: null }),
      });

      const result = await canApproveContent();
      expect(result).toBe(false);
    });
  });
});
```

Adjust mocking patterns based on actual test file patterns in the codebase.
  </action>
  <verify>npm test permissionsService passes</verify>
  <done>permissionsService tests verify role-based approval logic</done>
</task>

<task type="auto">
  <name>Task 2: Create/extend approvalService tests</name>
  <files>tests/unit/approvalService.test.js</files>
  <action>
Create or extend tests/unit/approvalService.test.js:

```javascript
import { describe, it, expect, vi, beforeEach } from 'vitest';

vi.mock('../../src/supabase', () => ({
  supabase: {
    auth: { getUser: vi.fn() },
    from: vi.fn(),
  },
}));

vi.mock('../../src/services/emailService', () => ({
  sendApprovalDecisionEmail: vi.fn().mockResolvedValue({ success: true }),
}));

import { supabase } from '../../src/supabase';
import { sendApprovalDecisionEmail } from '../../src/services/emailService';
import {
  APPROVAL_STATUS,
  REVIEW_STATUS,
  RESOURCE_TYPES,
  requestApproval,
  approveReview,
  rejectReview,
  getOpenReviewForResource,
} from '../../src/services/approvalService';

describe('approvalService', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('RESOURCE_TYPES', () => {
    it('includes scene resource type', () => {
      expect(RESOURCE_TYPES.SCENE).toBe('scene');
    });

    it('includes all content types', () => {
      expect(RESOURCE_TYPES).toEqual({
        PLAYLIST: 'playlist',
        LAYOUT: 'layout',
        CAMPAIGN: 'campaign',
        SCENE: 'scene',
      });
    });
  });

  describe('requestApproval', () => {
    it('creates review request for playlist', async () => {
      const userId = 'user-1';
      const playlistId = 'playlist-1';

      supabase.auth.getUser.mockResolvedValue({ data: { user: { id: userId } } });

      const insertMock = vi.fn().mockReturnValue({
        select: vi.fn().mockReturnValue({
          single: vi.fn().mockResolvedValue({
            data: { id: 'review-1', status: 'open' },
            error: null,
          }),
        }),
      });

      const updateMock = vi.fn().mockReturnValue({
        eq: vi.fn().mockResolvedValue({ error: null }),
      });

      supabase.from.mockImplementation((table) => {
        if (table === 'profiles') {
          return {
            select: vi.fn().mockReturnThis(),
            eq: vi.fn().mockReturnThis(),
            single: vi.fn().mockResolvedValue({
              data: { id: userId, managed_tenant_id: 'tenant-1' },
              error: null,
            }),
          };
        }
        if (table === 'review_requests') {
          return { insert: insertMock };
        }
        if (table === 'playlists') {
          return { update: updateMock };
        }
        return {};
      });

      const result = await requestApproval({
        resourceType: 'playlist',
        resourceId: playlistId,
        title: 'Review my playlist',
      });

      expect(result.status).toBe('open');
      expect(insertMock).toHaveBeenCalled();
      expect(updateMock).toHaveBeenCalled();
    });

    it('creates review request for scene', async () => {
      const userId = 'user-1';
      const sceneId = 'scene-1';

      supabase.auth.getUser.mockResolvedValue({ data: { user: { id: userId } } });

      supabase.from.mockImplementation((table) => {
        if (table === 'profiles') {
          return {
            select: vi.fn().mockReturnThis(),
            eq: vi.fn().mockReturnThis(),
            single: vi.fn().mockResolvedValue({
              data: { id: userId, managed_tenant_id: 'tenant-1' },
              error: null,
            }),
          };
        }
        if (table === 'review_requests') {
          return {
            insert: vi.fn().mockReturnValue({
              select: vi.fn().mockReturnValue({
                single: vi.fn().mockResolvedValue({
                  data: { id: 'review-1', resource_type: 'scene' },
                  error: null,
                }),
              }),
            }),
          };
        }
        if (table === 'scenes') {
          return {
            update: vi.fn().mockReturnValue({
              eq: vi.fn().mockResolvedValue({ error: null }),
            }),
          };
        }
        return {};
      });

      const result = await requestApproval({
        resourceType: 'scene',
        resourceId: sceneId,
        title: 'Review my scene',
      });

      expect(result.resource_type).toBe('scene');
    });
  });

  describe('rejectReview', () => {
    it('throws error if comment is empty', async () => {
      supabase.auth.getUser.mockResolvedValue({ data: { user: { id: 'user-1' } } });

      await expect(
        rejectReview('review-1', { comment: '' })
      ).rejects.toThrow('A comment is required when rejecting');
    });

    it('sends email notification on rejection', async () => {
      supabase.auth.getUser.mockResolvedValue({ data: { user: { id: 'user-1' } } });

      supabase.from.mockImplementation((table) => {
        if (table === 'review_requests') {
          return {
            select: vi.fn().mockReturnValue({
              eq: vi.fn().mockReturnValue({
                single: vi.fn().mockResolvedValue({
                  data: {
                    id: 'review-1',
                    resource_type: 'playlist',
                    resource_id: 'playlist-1',
                    requested_by_profile: { email: 'creator@test.com', full_name: 'Creator' },
                  },
                  error: null,
                }),
              }),
            }),
            update: vi.fn().mockReturnValue({
              eq: vi.fn().mockReturnValue({
                select: vi.fn().mockReturnValue({
                  single: vi.fn().mockResolvedValue({
                    data: { id: 'review-1', status: 'rejected' },
                    error: null,
                  }),
                }),
              }),
            }),
          };
        }
        if (table === 'profiles') {
          return {
            select: vi.fn().mockReturnThis(),
            eq: vi.fn().mockReturnThis(),
            single: vi.fn().mockResolvedValue({
              data: { full_name: 'Reviewer' },
              error: null,
            }),
          };
        }
        if (table === 'playlists') {
          return {
            update: vi.fn().mockReturnValue({
              eq: vi.fn().mockResolvedValue({ error: null }),
            }),
          };
        }
        return {};
      });

      await rejectReview('review-1', { comment: 'Needs more content' });

      // Verify email was attempted (async, so check mock was called)
      // Note: Email is fire-and-forget, so this tests the attempt
      expect(sendApprovalDecisionEmail).toHaveBeenCalledWith(
        expect.objectContaining({
          decision: 'rejected',
          feedback: 'Needs more content',
        })
      );
    });
  });

  describe('getOpenReviewForResource', () => {
    it('returns null when no open review exists', async () => {
      supabase.from.mockReturnValue({
        select: vi.fn().mockReturnThis(),
        eq: vi.fn().mockReturnThis(),
        order: vi.fn().mockReturnThis(),
        limit: vi.fn().mockReturnThis(),
        single: vi.fn().mockResolvedValue({
          data: null,
          error: { code: 'PGRST116' }, // No rows
        }),
      });

      const result = await getOpenReviewForResource('playlist', 'playlist-1');
      expect(result).toBeNull();
    });

    it('returns existing open review', async () => {
      const review = { id: 'review-1', status: 'open' };

      supabase.from.mockReturnValue({
        select: vi.fn().mockReturnThis(),
        eq: vi.fn().mockReturnThis(),
        order: vi.fn().mockReturnThis(),
        limit: vi.fn().mockReturnThis(),
        single: vi.fn().mockResolvedValue({ data: review, error: null }),
      });

      const result = await getOpenReviewForResource('scene', 'scene-1');
      expect(result).toEqual(review);
    });
  });
});
```
  </action>
  <verify>npm test approvalService passes</verify>
  <done>approvalService tests verify scene support and email notifications</done>
</task>

<task type="auto">
  <name>Task 3: Run full test suite verification</name>
  <files>N/A</files>
  <action>
Run the test suite to verify all Phase 12 tests pass:

```bash
npm test -- --run
```

Check for:
1. New permissionsService tests pass
2. New approvalService tests pass
3. No regressions in existing tests
4. All APR-* requirements have test coverage:
   - APR-01: Content submission (covered by requestApproval tests)
   - APR-02: Review queue (covered by getOpenReviewForResource, fetchOpenReviews)
   - APR-03: Approve/reject (covered by approveReview, rejectReview tests)
   - APR-04: Publishing gate (would need integration test - mark as manual verification)
   - APR-05: Email notifications (covered by email mock assertions)

Document test results and any failures that need attention.
  </action>
  <verify>npm test passes with all Phase 12 tests</verify>
  <done>Test suite passes, APR requirements have test coverage</done>
</task>

</tasks>

<verification>
1. permissionsService.test.js exists with requiresApproval tests
2. approvalService.test.js exists with scene support and email tests
3. npm test runs without failures
4. New tests verify APR-01 through APR-05 requirements
</verification>

<success_criteria>
- requiresApproval returns true for editor/viewer, false for owner/manager
- requestApproval works for 'scene' resource type
- rejectReview requires comment
- Email notifications called on approve/reject
- No test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/12-content-approval/12-09-SUMMARY.md`
</output>
